---
sidebar_position: 1
---

# Your First Dataflow
Hydroflow+ programs require special structure to support code generation and distributed deployments. There are three main components of a Hydroflow+ program:
- The **flow graph** describes the dataflow logic of the program.
- The **runtime** wraps the dataflow in an executable Rust binary.
- The **deployment** describes how to map the flow graph to instances of the runtime. This is only needed for distributed deployments.

:::tip

We recommend using the Hydroflow+ template to get started with a new project. The template comes with a pre-configured build system and the following example pre-implemented.

```bash
$ cargo install cargo-generate
$ cargo generate hydro-project/hydroflow-plus-template
```

:::


Let's look a minimal example of a Hydroflow+ program. We'll start with a simple flow graph that prints out the first 10 natural numbers. First, we'll define the **flow graph**.


## The Flow Graph
```rust title="flow/src/first_ten.rs"
use hydroflow_plus::*;
use hydroflow_plus::node::*;
use stageleft::*;

pub fn first_ten<'a, D: LocalDeploy<'a>>(
    graph: &'a GraphBuilder<'a, D>,
    node_builder: &impl NodeBuilder<'a, D>
) {}
```

The `graph` variable gives us access to the builder API for constructing the flow graph. The `node_builder` variable defines how to construct the nodes of the flow graph. For now, we will only use the builder once, to create a single node.

```rust
pub fn first_ten<'a, D: LocalDeploy<'a>>(
    graph: &'a GraphBuilder<'a, D>,
    node_builder: &impl NodeBuilder<'a, D>
) {
    let node = graph.node(node_builder);
}
```

Now, we can build out the logic of the node. First, we instantiate a stream that emits the first 10 natural numbers.

```rust
let numbers = node.source_iter(q!(0..10));
```

In Hydroflow+, whenever there are snippets of code that will be executed during runtime, we use the `q!` macro to mark them. This includes both static sources of data as well as closures that transform them. For example, to print out these numbers, we can use the `for_each` operator:

```rust
numbers.for_each(q!(|n| println!("{}", n)));
```

## The Runtime
Next, we need to instantiate our flow graph into a runnable Rust binary. We do this by defining a Stageleft entrypoint for the graph, and then instantiating this inside a separate Rust binary.

To define the entrypoint, we use the `#[stageleft::entry]` macro, which takes the graph being built and returns a generated Hydroflow program:

```rust title="flow/src/first_ten.rs"
#[stageleft::entry]
pub fn first_ten_runtime<'a>(
    graph: &'a GraphBuilder<'a, SingleGraph>
) -> impl Quoted<'a, Hydroflow<'a>> {
    first_ten(graph, &());
    graph.build_single()
}
```

Because we are using a `SingleGraph` deployment, we can use the `build_single` method to generate a runnable Hydroflow program. Stageleft entries are usable as macros from other programs. In our case, we will instantiate our entrypoint from the Rust binary for our dataflow. We can create a new file `src/bin/first_ten.rs` with the following contents:

```rust title="flow/src/bin/first_ten.rs"
#[tokio::main]
async fn main() {
    flow::first_ten::first_ten_runtime!().run_async().await;
}
```

We can now run this binary to see the output of our dataflow:

```bash
$ cargo run -p flow --bin first_ten
0
1
2
3
4
5
6
7
8
9
```

In the next section, we will look at how to extend this program to run on multiple nodes.
