---
sidebar_position: 3
---

# Clusters
A key restriction of nodes in Hydroflow+ is that there can only be one instance of the computation assigned to each node across the entire distributed system. This is fine for simple applications with only pipelined computation, but for scaling out we need the ability to have _multiple instances of the same computation_ running in parallel.

Clusters solve this by providing an nearly-identical API to nodes, but representing a **set of instances** running the same computation instead of a single one. What changes when using a cluster is sending data, since we need to specify _which_ instance(s) of the computation to send the data to.

## Computing on Clusters
Instantiating clusters is done using the `cluster` method on `GraphBuilder`, taking a `ClusterBuilder`:
```rust
pub fn my_flow<'a, D: Deploy<'a>>(
    graph: &'a GraphBuilder<'a, D>,
    cluster_builder: &impl ClusterBuilder<'a, D>
) {
    let cluster = graph.cluster(cluster_builder);
}
```

This API follows the same pattern as nodes, where a cluster builder represents a _template_ for a cluster, which can be instantiated multiple times to create multiple clusters.

Instantiating streams on clusters uses the same APIs as streams: `source_iter` and `source_stream` are both available. But when using these APIs, the root streams will be instantiated on _all_ instances in the cluster.

```rust
let stream = cluster.source_iter(q!(vec![1, 2, 3]));

stream.for_each(q!(|x| println!("{}", x)))
// will print 1, 2, 3 on **each** instance
```

## Sending Data
Because clusters represent a set of instances, adding networking requires us to specify _which_ instance(s) to send data to. Clusters provide different APIs depending on if the source or receiver is a cluster or a node.

Elements in a cluster are identified by a **cluster ID** (a `u32`). To get the IDs of all instances in a cluster, use the `ids` method on cluster, which returns a quoted expression of type `&Vec<u32>`. All IDs always are ranging from 0 through the length of the IDs vector.

This can then be passed into `source_iter` to load the IDs into the graph.
```rust
let stream = node.source_iter(cluster.ids()).cloned();
```

### One-to-Many
When sending data from a node to a cluster, the primary API is `demux_{bincode,bytes}`, which takes a stream of tuples of the form `(u32, T)` and sends each `T` element to the instance with the matching `u32` ID.

This is useful for partitioning data across instances. For example, we can partition a stream of elements in a round-robin fashion by using `enumerate` to add a sequence number to each element, then using `demux_bincode` to send each element to the instance with the matching sequence number:
```rust
let cluster_ids = cluster.ids();
let stream = node.source_iter(q!(vec![123, 456, 789]))
    .enumerate()
    .map(q!(|(i, x)| (
        i % cluster_ids.len() as u32,
        x
    )))
    .demux_bincode(cluster);
```

To broadcast data to all instances in a cluster, use `broadcast_{bincode,bytes}`, which acts as a shortcut that uses `demux` under the hood.

```rust
let stream = node.source_iter(q!(vec![123, 456, 789]))
    .broadcast_bincode(cluster);
```

### Many-to-One
TODO

### Many-to-Many
TODO
