<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `/home/runner/work/hydroflow/hydroflow/target/debug/build/hydroflow_plus-fd01b551d68eca55/out/lib_pub.rs`."><title>lib_pub.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../../../../../../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../../../../../../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../../../../../../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../../../../../../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../../../../../../../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../../../../../../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../../../../../../../../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../../../../../../../../../../static.files/rustdoc-9ee3a5e31a2afa3e.css"><meta name="rustdoc-vars" data-root-path="../../../../../../../../../../../../" data-static-root-path="../../../../../../../../../../../../static.files/" data-current-crate="hydroflow_plus" data-themes="" data-resource-suffix="" data-rustdoc-version="1.75.0-nightly (cd674d617 2023-10-24)" data-channel="nightly" data-search-js="search-8fbf244ebcf71464.js" data-settings-js="settings-74424d7eec62a23e.js" ><script src="../../../../../../../../../../../../static.files/storage-fec3eaa3851e447d.js"></script><script defer src="../../../../../../../../../../../../static.files/src-script-3280b574d94e47b4.js"></script><script defer src="../../../../../../../../../../../../src-files.js"></script><script defer src="../../../../../../../../../../../../static.files/main-5f34af1a0ee6bacd.js"></script><noscript><link rel="stylesheet" href="../../../../../../../../../../../../static.files/noscript-5d8b3c7633ad77ba.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../../../../../../../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../../../../../../../../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../../../../../../../../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc src"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"></nav><main><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../../../../../../../../../../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../../../../../../../../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../../../../../../../../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="example-wrap"><div data-nosnippet><pre class="src-line-numbers"><a href="#1" id="1">1</a>
</pre></div><pre class="rust"><code><span class="kw">pub use </span>std :: marker :: PhantomData ; <span class="kw">pub use </span>hydroflow :: scheduled :: context :: Context ; <span class="kw">pub use </span>hydroflow :: scheduled :: graph :: Hydroflow ; <span class="kw">pub use </span>hydroflow :: * ; <span class="kw">pub use </span>proc_macro2 :: TokenStream ; <span class="kw">pub use </span>quote :: quote ; <span class="kw">pub use </span>stageleft :: runtime_support :: FreeVariable ; <span class="kw">pub use </span>stageleft :: Quoted ; <span class="kw">pub mod </span>runtime_support { <span class="kw">pub use </span>bincode ; } <span class="kw">pub mod </span>stream { <span class="kw">pub use </span>std :: cell :: RefCell ; <span class="kw">pub use </span>std :: hash :: Hash ; <span class="kw">pub use </span>std :: io ; <span class="kw">pub use </span>std :: marker :: PhantomData ; <span class="kw">pub use </span>hydroflow :: bytes :: { Bytes , BytesMut } ; <span class="kw">pub use </span>hydroflow :: futures :: Sink ; <span class="kw">pub use </span>hydroflow_lang :: parse :: Pipeline ; <span class="kw">pub use </span>proc_macro2 :: { Span , TokenStream } ; <span class="kw">pub use </span>quote :: quote ; <span class="kw">pub use </span>serde :: de :: DeserializeOwned ; <span class="kw">pub use </span>serde :: Serialize ; <span class="kw">pub use </span>stageleft :: { q , IntoQuotedMut , Quoted } ; <span class="kw">pub use </span>syn :: parse_quote ; <span class="kw">pub use </span>syn :: visit_mut :: VisitMut ; <span class="kw">pub use crate </span>:: builder :: Builders ; <span class="kw">pub use crate </span>:: location :: { Cluster , HfSendManyToMany , HfSendManyToOne , HfSendOneToMany , HfSendOneToOne , Location , } ; <span class="kw">pub use crate </span>:: stream :: Async ; <span class="kw">pub use crate </span>:: stream :: Windowed ; <span class="kw">pub use crate </span>:: stream :: Stream ; # [cfg (feature = <span class="string">&quot;macro&quot;</span>)] <span class="kw">impl </span>&lt; <span class="lifetime">&#39;a </span>, T , W , N : Location &lt; <span class="lifetime">&#39;a </span>&gt; &gt; Stream &lt; <span class="lifetime">&#39;a </span>, T , W , N &gt; { <span class="kw">fn </span>pipeline_op &lt; U , W2 &gt; (&amp; <span class="self">self </span>, pipeline : Pipeline , produces_delta : bool) -&gt; Stream &lt; <span class="lifetime">&#39;a </span>, U , W2 , N &gt; { <span class="kw">let </span>next_id = { <span class="kw">let </span><span class="kw-2">mut </span>next_id = <span class="self">self </span>. next_id . borrow_mut () ; <span class="kw">let </span>id = * next_id ; * next_id += <span class="number">1 </span>; id } ; <span class="kw">let </span>self_ident = &amp; <span class="self">self </span>. ident ; <span class="kw">let </span>ident = syn :: Ident :: new (&amp; format ! (<span class="string">&quot;stream_{}&quot; </span>, next_id) , Span :: call_site ()) ; <span class="self">self </span>. builders . borrow_mut () . as_mut () . unwrap () . entry (<span class="self">self </span>. node . id ()) . or_default () . add_statement (parse_quote ! { # ident = # self_ident -&gt; # pipeline -&gt; tee () ; }) ; Stream { ident , node : <span class="self">self </span>. node . clone () , next_id : <span class="self">self </span>. next_id , builders : <span class="self">self </span>. builders , is_delta : produces_delta , _phantom : PhantomData , } } # [doc = <span class="string">&quot; Reifies the stream to ensure that it is not producing deltas.&quot;</span>] <span class="kw">pub </span>(<span class="kw">crate</span>) <span class="kw">fn </span>ensure_concrete (&amp; <span class="self">self</span>) -&gt; Stream &lt; <span class="lifetime">&#39;a </span>, T , Windowed , N &gt; { <span class="kw">if </span><span class="self">self </span>. is_delta { <span class="self">self </span>. pipeline_op (parse_quote ! (persist ()) , <span class="bool-val">false</span>) } <span class="kw">else </span>{ <span class="self">self </span>. assume_windowed () } } <span class="kw">pub fn </span>map &lt; U , F : Fn (T) -&gt; U + <span class="lifetime">&#39;a </span>&gt; (&amp; <span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">&#39;a </span>, F &gt;) -&gt; Stream &lt; <span class="lifetime">&#39;a </span>, U , W , N &gt; { <span class="kw">let </span>f = f . splice () ; <span class="self">self </span>. pipeline_op (parse_quote ! (map (# f)) , <span class="self">self </span>. is_delta) } <span class="kw">pub fn </span>flat_map &lt; U , I : IntoIterator &lt; Item = U &gt; , F : Fn (T) -&gt; I + <span class="lifetime">&#39;a </span>&gt; (&amp; <span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">&#39;a </span>, F &gt; ,) -&gt; Stream &lt; <span class="lifetime">&#39;a </span>, U , W , N &gt; { <span class="kw">let </span>f = f . splice () ; <span class="self">self </span>. pipeline_op (parse_quote ! (flat_map (# f)) , <span class="self">self </span>. is_delta) } <span class="kw">pub fn </span>enumerate (&amp; <span class="self">self</span>) -&gt; Stream &lt; <span class="lifetime">&#39;a </span>, (usize , T) , W , N &gt; { <span class="self">self </span>. ensure_concrete () . pipeline_op (parse_quote ! (enumerate ()) , <span class="self">self </span>. is_delta) } <span class="kw">pub fn </span>inspect &lt; F : Fn (&amp; T) + <span class="lifetime">&#39;a </span>&gt; (&amp; <span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">&#39;a </span>, F &gt;) -&gt; Stream &lt; <span class="lifetime">&#39;a </span>, T , W , N &gt; { <span class="kw">let </span>f = f . splice () ; <span class="self">self </span>. ensure_concrete () . pipeline_op (parse_quote ! (inspect (# f)) , <span class="self">self </span>. is_delta) } <span class="kw">pub fn </span>filter &lt; F : Fn (&amp; T) -&gt; bool + <span class="lifetime">&#39;a </span>&gt; (&amp; <span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">&#39;a </span>, F &gt; ,) -&gt; Stream &lt; <span class="lifetime">&#39;a </span>, T , W , N &gt; { <span class="kw">let </span>f = f . splice () ; <span class="self">self </span>. pipeline_op (parse_quote ! (filter (# f)) , <span class="self">self </span>. is_delta) } <span class="kw">pub fn </span>filter_map &lt; U , F : Fn (T) -&gt; <span class="prelude-ty">Option </span>&lt; U &gt; + <span class="lifetime">&#39;a </span>&gt; (&amp; <span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">&#39;a </span>, F &gt; ,) -&gt; Stream &lt; <span class="lifetime">&#39;a </span>, U , W , N &gt; { <span class="kw">let </span>f = f . splice () ; <span class="self">self </span>. pipeline_op (parse_quote ! (filter_map (# f)) , <span class="self">self </span>. is_delta) } <span class="kw">pub fn </span>cross_product &lt; O &gt; (&amp; <span class="self">self </span>, other : &amp; Stream &lt; <span class="lifetime">&#39;a </span>, O , W , N &gt;) -&gt; Stream &lt; <span class="lifetime">&#39;a </span>, (T , O) , W , N &gt; { <span class="kw">if </span><span class="self">self </span>. node . id () != other . node . id () { panic ! (<span class="string">&quot;cross_product must be called on streams on the same node&quot;</span>) ; } <span class="kw">let </span>next_id = { <span class="kw">let </span><span class="kw-2">mut </span>next_id = <span class="self">self </span>. next_id . borrow_mut () ; <span class="kw">let </span>id = * next_id ; * next_id += <span class="number">1 </span>; id } ; <span class="kw">let </span>self_ident = &amp; <span class="self">self </span>. ident ; <span class="kw">let </span>other_ident = &amp; other . ident ; <span class="kw">let </span>ident = syn :: Ident :: new (&amp; format ! (<span class="string">&quot;stream_{}&quot; </span>, next_id) , Span :: call_site ()) ; <span class="kw">let </span><span class="kw-2">mut </span>builders = <span class="self">self </span>. builders . borrow_mut () ; <span class="kw">let </span>builder = builders . as_mut () . unwrap () . entry (<span class="self">self </span>. node . id ()) . or_default () ; <span class="kw">let </span>output_delta = <span class="kw">match </span>(<span class="self">self </span>. is_delta , other . is_delta) { (<span class="bool-val">true </span>, <span class="bool-val">true</span>) =&gt; { builder . add_statement (parse_quote ! { # ident = cross_join ::&lt;<span class="lifetime">&#39;static </span>, <span class="lifetime">&#39;static </span>&gt; () -&gt; tee () ; }) ; <span class="bool-val">false </span>} (<span class="bool-val">true </span>, <span class="bool-val">false</span>) =&gt; { builder . add_statement (parse_quote ! { # ident = cross_join ::&lt;<span class="lifetime">&#39;static </span>, <span class="lifetime">&#39;tick </span>&gt; () -&gt; tee () ; }) ; <span class="bool-val">false </span>} (<span class="bool-val">false </span>, <span class="bool-val">true</span>) =&gt; { builder . add_statement (parse_quote ! { # ident = cross_join ::&lt;<span class="lifetime">&#39;tick </span>, <span class="lifetime">&#39;static </span>&gt; () -&gt; tee () ; }) ; <span class="bool-val">false </span>} (<span class="bool-val">false </span>, <span class="bool-val">false</span>) =&gt; { builder . add_statement (parse_quote ! { # ident = cross_join ::&lt;<span class="lifetime">&#39;tick </span>, <span class="lifetime">&#39;tick </span>&gt; () -&gt; tee () ; }) ; <span class="bool-val">false </span>} } ; builder . add_statement (parse_quote ! { # self_ident -&gt; [<span class="number">0</span>] # ident ; }) ; builder . add_statement (parse_quote ! { # other_ident -&gt; [<span class="number">1</span>] # ident ; }) ; Stream { ident , node : <span class="self">self </span>. node . clone () , next_id : <span class="self">self </span>. next_id , builders : <span class="self">self </span>. builders , is_delta : output_delta , _phantom : PhantomData , } } <span class="kw">pub fn </span>union (&amp; <span class="self">self </span>, other : &amp; Stream &lt; <span class="lifetime">&#39;a </span>, T , W , N &gt;) -&gt; Stream &lt; <span class="lifetime">&#39;a </span>, T , W , N &gt; { <span class="kw">if </span><span class="self">self </span>. node . id () != other . node . id () { panic ! (<span class="string">&quot;union must be called on streams on the same node&quot;</span>) ; } <span class="kw">let </span>next_id = { <span class="kw">let </span><span class="kw-2">mut </span>next_id = <span class="self">self </span>. next_id . borrow_mut () ; <span class="kw">let </span>id = * next_id ; * next_id += <span class="number">1 </span>; id } ; <span class="kw">let </span>self_ident = &amp; <span class="self">self </span>. ensure_concrete () . ident ; <span class="kw">let </span>other_ident = &amp; other . ensure_concrete () . ident ; <span class="kw">let </span>ident = syn :: Ident :: new (&amp; format ! (<span class="string">&quot;stream_{}&quot; </span>, next_id) , Span :: call_site ()) ; <span class="kw">let </span><span class="kw-2">mut </span>builders = <span class="self">self </span>. builders . borrow_mut () ; <span class="kw">let </span>builder = builders . as_mut () . unwrap () . entry (<span class="self">self </span>. node . id ()) . or_default () ; builder . add_statement (parse_quote ! { # ident = union () -&gt; tee () ; }) ; builder . add_statement (parse_quote ! { # self_ident -&gt; [<span class="number">0</span>] # ident ; }) ; builder . add_statement (parse_quote ! { # other_ident -&gt; [<span class="number">1</span>] # ident ; }) ; Stream { ident , node : <span class="self">self </span>. node . clone () , next_id : <span class="self">self </span>. next_id , builders : <span class="self">self </span>. builders , is_delta : <span class="bool-val">false </span>, _phantom : PhantomData , } } <span class="kw">pub fn </span>for_each &lt; F : Fn (T) + <span class="lifetime">&#39;a </span>&gt; (&amp; <span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">&#39;a </span>, F &gt;) { <span class="kw">let </span>self_ident = &amp; <span class="self">self </span>. ensure_concrete () . ident ; <span class="kw">let </span>f = f . splice () ; <span class="self">self </span>. builders . borrow_mut () . as_mut () . unwrap () . entry (<span class="self">self </span>. node . id ()) . or_default () . add_statement (parse_quote ! { # self_ident -&gt; for_each (# f) ; }) ; } <span class="kw">pub fn </span>dest_sink &lt; S : Unpin + Sink &lt; T &gt; + <span class="lifetime">&#39;a </span>&gt; (&amp; <span class="self">self </span>, sink : <span class="kw">impl </span>Quoted &lt; <span class="lifetime">&#39;a </span>, S &gt;) { <span class="kw">let </span>self_ident = &amp; <span class="self">self </span>. ensure_concrete () . ident ; <span class="kw">let </span>sink = sink . splice () ; <span class="self">self </span>. builders . borrow_mut () . as_mut () . unwrap () . entry (<span class="self">self </span>. node . id ()) . or_default () . add_statement (parse_quote ! { # self_ident -&gt; dest_sink (# sink) ; }) ; } <span class="kw">pub fn </span>all_ticks (&amp; <span class="self">self</span>) -&gt; Stream &lt; <span class="lifetime">&#39;a </span>, T , Windowed , N &gt; { <span class="kw">if </span><span class="self">self </span>. is_delta { <span class="self">self </span>. ensure_concrete () . all_ticks () } <span class="kw">else </span>{ Stream { ident : <span class="self">self </span>. ident . clone () , node : <span class="self">self </span>. node . clone () , next_id : <span class="self">self </span>. next_id , builders : <span class="self">self </span>. builders , is_delta : <span class="bool-val">true </span>, _phantom : PhantomData , } } } <span class="kw">pub fn </span>assume_windowed (&amp; <span class="self">self</span>) -&gt; Stream &lt; <span class="lifetime">&#39;a </span>, T , Windowed , N &gt; { Stream { ident : <span class="self">self </span>. ident . clone () , node : <span class="self">self </span>. node . clone () , next_id : <span class="self">self </span>. next_id , builders : <span class="self">self </span>. builders , is_delta : <span class="self">self </span>. is_delta , _phantom : PhantomData , } } } # [cfg (feature = <span class="string">&quot;macro&quot;</span>)] <span class="kw">impl </span>&lt; <span class="lifetime">&#39;a </span>, T , N : Location &lt; <span class="lifetime">&#39;a </span>&gt; &gt; Stream &lt; <span class="lifetime">&#39;a </span>, T , Async , N &gt; { <span class="kw">pub fn </span>tick_batch (&amp; <span class="self">self</span>) -&gt; Stream &lt; <span class="lifetime">&#39;a </span>, T , Windowed , N &gt; { Stream { ident : <span class="self">self </span>. ident . clone () , node : <span class="self">self </span>. node . clone () , next_id : <span class="self">self </span>. next_id , builders : <span class="self">self </span>. builders , is_delta : <span class="self">self </span>. is_delta , _phantom : PhantomData , } } } # [cfg (feature = <span class="string">&quot;macro&quot;</span>)] <span class="kw">impl </span>&lt; <span class="lifetime">&#39;a </span>, T , N : Location &lt; <span class="lifetime">&#39;a </span>&gt; &gt; Stream &lt; <span class="lifetime">&#39;a </span>, T , Windowed , N &gt; { <span class="kw">pub fn </span>fold &lt; A , I : Fn () -&gt; A + <span class="lifetime">&#39;a </span>, C : Fn (&amp; <span class="kw-2">mut </span>A , T) &gt; (&amp; <span class="self">self </span>, init : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">&#39;a </span>, I &gt; , comb : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">&#39;a </span>, C &gt; ,) -&gt; Stream &lt; <span class="lifetime">&#39;a </span>, A , Windowed , N &gt; { <span class="kw">let </span>init = init . splice () ; <span class="kw">let </span>comb = comb . splice () ; <span class="kw">if </span><span class="self">self </span>. is_delta { <span class="self">self </span>. pipeline_op (parse_quote ! (fold ::&lt;<span class="lifetime">&#39;static </span>&gt; (# init , # comb)) , <span class="bool-val">false</span>) } <span class="kw">else </span>{ <span class="self">self </span>. pipeline_op (parse_quote ! (fold ::&lt;<span class="lifetime">&#39;tick </span>&gt; (# init , # comb)) , <span class="bool-val">false</span>) } } <span class="kw">pub fn </span>reduce &lt; C : Fn (&amp; <span class="kw-2">mut </span>T , T) + <span class="lifetime">&#39;a </span>&gt; (&amp; <span class="self">self </span>, comb : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">&#39;a </span>, C &gt; ,) -&gt; Stream &lt; <span class="lifetime">&#39;a </span>, T , Windowed , N &gt; { <span class="kw">let </span>comb = comb . splice () ; <span class="kw">if </span><span class="self">self </span>. is_delta { <span class="self">self </span>. pipeline_op (parse_quote ! (reduce ::&lt;<span class="lifetime">&#39;static </span>&gt; (# comb)) , <span class="bool-val">false</span>) } <span class="kw">else </span>{ <span class="self">self </span>. pipeline_op (parse_quote ! (reduce ::&lt;<span class="lifetime">&#39;tick </span>&gt; (# comb)) , <span class="bool-val">false</span>) } } <span class="kw">pub fn </span>count (&amp; <span class="self">self</span>) -&gt; Stream &lt; <span class="lifetime">&#39;a </span>, usize , Windowed , N &gt; { <span class="self">self </span>. fold (q ! (|| <span class="number">0usize</span>) , q ! (| count , <span class="kw">_ </span>| * count += <span class="number">1</span>)) } <span class="kw">pub fn </span>delta (&amp; <span class="self">self</span>) -&gt; Stream &lt; <span class="lifetime">&#39;a </span>, T , Windowed , N &gt; { <span class="kw">if </span><span class="self">self </span>. is_delta { Stream { ident : <span class="self">self </span>. ident . clone () , node : <span class="self">self </span>. node . clone () , next_id : <span class="self">self </span>. next_id , builders : <span class="self">self </span>. builders , is_delta : <span class="bool-val">false </span>, _phantom : PhantomData , } } <span class="kw">else </span>{ <span class="self">self </span>. pipeline_op (parse_quote ! (multiset_delta ()) , <span class="bool-val">false</span>) } } <span class="kw">pub fn </span>unique (&amp; <span class="self">self</span>) -&gt; Stream &lt; <span class="lifetime">&#39;a </span>, T , Windowed , N &gt; <span class="kw">where </span>T : Eq + Hash , { <span class="self">self </span>. ensure_concrete () . pipeline_op (parse_quote ! (unique ::&lt;<span class="lifetime">&#39;tick </span>&gt; ()) , <span class="bool-val">false</span>) } <span class="kw">pub fn </span>sample_every (&amp; <span class="self">self </span>, duration : <span class="kw">impl </span>Quoted &lt; <span class="lifetime">&#39;a </span>, std :: time :: Duration &gt; + Copy + <span class="lifetime">&#39;a </span>,) -&gt; Stream &lt; <span class="lifetime">&#39;a </span>, T , Windowed , N &gt; { <span class="self">self </span>. cross_product (&amp; <span class="self">self </span>. node . source_interval (duration) . tick_batch ()) . map (q ! (| (a , <span class="kw">_</span>) | a)) } } # [cfg (feature = <span class="string">&quot;macro&quot;</span>)] <span class="kw">impl </span>&lt; <span class="lifetime">&#39;a </span>, T : Clone , W , N : Location &lt; <span class="lifetime">&#39;a </span>&gt; &gt; Stream &lt; <span class="lifetime">&#39;a </span>, &amp; T , W , N &gt; { <span class="kw">pub fn </span>cloned (&amp; <span class="self">self</span>) -&gt; Stream &lt; <span class="lifetime">&#39;a </span>, T , W , N &gt; { <span class="self">self </span>. pipeline_op (parse_quote ! (map (| d | d . clone ())) , <span class="self">self </span>. is_delta) } } # [cfg (feature = <span class="string">&quot;macro&quot;</span>)] <span class="kw">impl </span>&lt; <span class="lifetime">&#39;a </span>, K , V1 , W , N : Location &lt; <span class="lifetime">&#39;a </span>&gt; &gt; Stream &lt; <span class="lifetime">&#39;a </span>, (K , V1) , W , N &gt; { <span class="kw">pub fn </span>join &lt; W2 , V2 &gt; (&amp; <span class="self">self </span>, n : &amp; Stream &lt; <span class="lifetime">&#39;a </span>, (K , V2) , W2 , N &gt;) -&gt; Stream &lt; <span class="lifetime">&#39;a </span>, (K , (V1 , V2)) , W , N &gt; <span class="kw">where </span>K : Eq + Hash , { <span class="kw">if </span><span class="self">self </span>. node . id () != n . node . id () { panic ! (<span class="string">&quot;join must be called on streams on the same node&quot;</span>) ; } <span class="kw">let </span>next_id = { <span class="kw">let </span><span class="kw-2">mut </span>next_id = <span class="self">self </span>. next_id . borrow_mut () ; <span class="kw">let </span>id = * next_id ; * next_id += <span class="number">1 </span>; id } ; <span class="kw">let </span>self_ident = &amp; <span class="self">self </span>. ident ; <span class="kw">let </span>other_ident = &amp; n . ident ; <span class="kw">let </span>ident = syn :: Ident :: new (&amp; format ! (<span class="string">&quot;stream_{}&quot; </span>, next_id) , Span :: call_site ()) ; <span class="kw">let </span><span class="kw-2">mut </span>builders = <span class="self">self </span>. builders . borrow_mut () ; <span class="kw">let </span>builder = builders . as_mut () . unwrap () . entry (<span class="self">self </span>. node . id ()) . or_default () ; <span class="kw">let </span>output_delta = <span class="kw">match </span>(<span class="self">self </span>. is_delta , n . is_delta) { (<span class="bool-val">true </span>, <span class="bool-val">true</span>) =&gt; { builder . add_statement (parse_quote ! { # ident = join ::&lt;<span class="lifetime">&#39;static </span>, <span class="lifetime">&#39;static </span>&gt; () -&gt; tee () ; }) ; <span class="bool-val">false </span>} (<span class="bool-val">true </span>, <span class="bool-val">false</span>) =&gt; { builder . add_statement (parse_quote ! { # ident = join ::&lt;<span class="lifetime">&#39;static </span>, <span class="lifetime">&#39;tick </span>&gt; () -&gt; tee () ; }) ; <span class="bool-val">false </span>} (<span class="bool-val">false </span>, <span class="bool-val">true</span>) =&gt; { builder . add_statement (parse_quote ! { # ident = join ::&lt;<span class="lifetime">&#39;tick </span>, <span class="lifetime">&#39;static </span>&gt; () -&gt; tee () ; }) ; <span class="bool-val">false </span>} (<span class="bool-val">false </span>, <span class="bool-val">false</span>) =&gt; { builder . add_statement (parse_quote ! { # ident = join ::&lt;<span class="lifetime">&#39;tick </span>, <span class="lifetime">&#39;tick </span>&gt; () -&gt; tee () ; }) ; <span class="bool-val">false </span>} } ; builder . add_statement (parse_quote ! { # self_ident -&gt; [<span class="number">0</span>] # ident ; }) ; builder . add_statement (parse_quote ! { # other_ident -&gt; [<span class="number">1</span>] # ident ; }) ; Stream { ident , node : <span class="self">self </span>. node . clone () , next_id : <span class="self">self </span>. next_id , builders : <span class="self">self </span>. builders , is_delta : output_delta , _phantom : PhantomData , } } } # [cfg (feature = <span class="string">&quot;macro&quot;</span>)] <span class="kw">impl </span>&lt; <span class="lifetime">&#39;a </span>, K : Eq + Hash , V , N : Location &lt; <span class="lifetime">&#39;a </span>&gt; &gt; Stream &lt; <span class="lifetime">&#39;a </span>, (K , V) , Windowed , N &gt; { <span class="kw">pub fn </span>fold_keyed &lt; A , I : Fn () -&gt; A + <span class="lifetime">&#39;a </span>, C : Fn (&amp; <span class="kw-2">mut </span>A , V) + <span class="lifetime">&#39;a </span>&gt; (&amp; <span class="self">self </span>, init : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">&#39;a </span>, I &gt; , comb : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">&#39;a </span>, C &gt; ,) -&gt; Stream &lt; <span class="lifetime">&#39;a </span>, (K , A) , Windowed , N &gt; { <span class="kw">let </span>init = init . splice () ; <span class="kw">let </span>comb = comb . splice () ; <span class="kw">if </span><span class="self">self </span>. is_delta { <span class="self">self </span>. pipeline_op (parse_quote ! (fold_keyed ::&lt;<span class="lifetime">&#39;static </span>&gt; (# init , # comb)) , <span class="bool-val">false</span>) } <span class="kw">else </span>{ <span class="self">self </span>. pipeline_op (parse_quote ! (fold_keyed ::&lt;<span class="lifetime">&#39;tick </span>&gt; (# init , # comb)) , <span class="bool-val">false</span>) } } <span class="kw">pub fn </span>reduce_keyed &lt; F : Fn (&amp; <span class="kw-2">mut </span>V , V) + <span class="lifetime">&#39;a </span>&gt; (&amp; <span class="self">self </span>, comb : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">&#39;a </span>, F &gt; ,) -&gt; Stream &lt; <span class="lifetime">&#39;a </span>, (K , V) , Windowed , N &gt; { <span class="kw">let </span>comb = comb . splice () ; <span class="kw">if </span><span class="self">self </span>. is_delta { <span class="self">self </span>. pipeline_op (parse_quote ! (reduce_keyed ::&lt;<span class="lifetime">&#39;static </span>&gt; (# comb)) , <span class="bool-val">false</span>) } <span class="kw">else </span>{ <span class="self">self </span>. pipeline_op (parse_quote ! (reduce_keyed ::&lt;<span class="lifetime">&#39;tick </span>&gt; (# comb)) , <span class="bool-val">false</span>) } } } <span class="kw">pub fn </span>get_this_crate () -&gt; TokenStream { <span class="kw">let </span>hydroflow_crate = proc_macro_crate :: crate_name (<span class="string">&quot;hydroflow_plus&quot;</span>) . expect (<span class="string">&quot;hydroflow_plus should be present in `Cargo.toml`&quot;</span>) ; <span class="kw">match </span>hydroflow_crate { proc_macro_crate :: FoundCrate :: Itself =&gt; quote ! { hydroflow_plus } , proc_macro_crate :: FoundCrate :: Name (name) =&gt; { <span class="kw">let </span>ident = syn :: Ident :: new (&amp; name , Span :: call_site ()) ; quote ! { # ident } } } } <span class="kw">pub use crate </span>:: stream :: RewriteAlloc ; # [cfg (feature = <span class="string">&quot;macro&quot;</span>)] <span class="kw">impl </span>VisitMut <span class="kw">for </span>RewriteAlloc { <span class="kw">fn </span>visit_path_mut (&amp; <span class="kw-2">mut </span><span class="self">self </span>, i : &amp; <span class="kw-2">mut </span>syn :: Path) { <span class="kw">if </span>i . segments . iter () . take (<span class="number">2</span>) . collect :: &lt; Vec &lt; <span class="kw">_ </span>&gt; &gt; () == vec ! [&amp; syn :: PathSegment :: from (syn :: Ident :: new (<span class="string">&quot;alloc&quot; </span>, Span :: call_site ())) , &amp; syn :: PathSegment :: from (syn :: Ident :: new (<span class="string">&quot;string&quot; </span>, Span :: call_site ())) ,] { * i . segments . first_mut () . unwrap () = syn :: PathSegment :: from (syn :: Ident :: new (<span class="string">&quot;std&quot; </span>, Span :: call_site ())) ; } } } <span class="kw">pub fn </span>node_send_direct &lt; <span class="lifetime">&#39;a </span>, T , W , N : Location &lt; <span class="lifetime">&#39;a </span>&gt; &gt; (me : &amp; Stream &lt; <span class="lifetime">&#39;a </span>, T , W , N &gt; , sink : Pipeline) { <span class="kw">let </span>self_ident = &amp; me . ident ; <span class="kw">let </span><span class="kw-2">mut </span>builders_borrowed = me . builders . borrow_mut () ; <span class="kw">let </span>builders = builders_borrowed . as_mut () . unwrap () ; builders . entry (me . node . id ()) . or_default () . add_statement (parse_quote ! { # self_ident -&gt; # sink ; }) ; } <span class="kw">pub fn </span>node_send_bincode &lt; <span class="lifetime">&#39;a </span>, T : Serialize , W , N : Location &lt; <span class="lifetime">&#39;a </span>&gt; &gt; (me : &amp; Stream &lt; <span class="lifetime">&#39;a </span>, T , W , N &gt; , sink : Pipeline ,) { <span class="kw">let </span>self_ident = &amp; me . ident ; <span class="kw">let </span><span class="kw-2">mut </span>builders_borrowed = me . builders . borrow_mut () ; <span class="kw">let </span>builders = builders_borrowed . as_mut () . unwrap () ; <span class="kw">let </span>root = get_this_crate () ; <span class="kw">let </span><span class="kw-2">mut </span>t_type : syn :: Type = syn :: parse_str (std :: any :: type_name :: &lt; T &gt; ()) . unwrap () ; RewriteAlloc { } . visit_type_mut (&amp; <span class="kw-2">mut </span>t_type) ; builders . entry (me . node . id ()) . or_default () . add_statement (parse_quote ! { # self_ident -&gt; map (| data | { # root :: runtime_support :: bincode :: serialize ::&lt;# t_type &gt; (&amp; data) . unwrap () . into () }) -&gt; # sink ; }) ; } <span class="kw">pub fn </span>cluster_demux_bincode &lt; <span class="lifetime">&#39;a </span>, T , W , N : Location &lt; <span class="lifetime">&#39;a </span>&gt; &gt; (me : &amp; Stream &lt; <span class="lifetime">&#39;a </span>, (u32 , T) , W , N &gt; , sink : Pipeline ,) { <span class="kw">let </span>self_ident = &amp; me . ident ; <span class="kw">let </span><span class="kw-2">mut </span>builders_borrowed = me . builders . borrow_mut () ; <span class="kw">let </span>builders = builders_borrowed . as_mut () . unwrap () ; <span class="kw">let </span>root = get_this_crate () ; <span class="kw">let </span><span class="kw-2">mut </span>t_type : syn :: Type = syn :: parse_str (std :: any :: type_name :: &lt; T &gt; ()) . unwrap () ; RewriteAlloc { } . visit_type_mut (&amp; <span class="kw-2">mut </span>t_type) ; builders . entry (me . node . id ()) . or_default () . add_statement (parse_quote ! { # self_ident -&gt; map (| (id , data) | { (id , # root :: runtime_support :: bincode :: serialize ::&lt;# t_type &gt; (&amp; data) . unwrap () . into ()) }) -&gt; # sink ; }) ; } <span class="kw">pub fn </span>node_recv_direct &lt; <span class="lifetime">&#39;a </span>, T , W , N : Location &lt; <span class="lifetime">&#39;a </span>&gt; , N2 : Location &lt; <span class="lifetime">&#39;a </span>&gt; &gt; (me : &amp; Stream &lt; <span class="lifetime">&#39;a </span>, T , W , N &gt; , other : &amp; N2 , source : Pipeline ,) -&gt; syn :: Ident { <span class="kw">let </span>recipient_next_id = { <span class="kw">let </span><span class="kw-2">mut </span>next_id = me . next_id . borrow_mut () ; <span class="kw">let </span>id = * next_id ; * next_id += <span class="number">1 </span>; id } ; <span class="kw">let </span>ident = syn :: Ident :: new (&amp; format ! (<span class="string">&quot;stream_{}&quot; </span>, recipient_next_id) , Span :: call_site ()) ; <span class="kw">let </span><span class="kw-2">mut </span>builders_borrowed = me . builders . borrow_mut () ; <span class="kw">let </span>builders = builders_borrowed . as_mut () . unwrap () ; builders . entry (other . id ()) . or_default () . add_statement (parse_quote ! { # ident = # source -&gt; tee () ; }) ; ident } <span class="kw">pub fn </span>node_recv_bincode &lt; <span class="lifetime">&#39;a </span>, T1 , T2 : DeserializeOwned , W , N : Location &lt; <span class="lifetime">&#39;a </span>&gt; , N2 : Location &lt; <span class="lifetime">&#39;a </span>&gt; &gt; (me : &amp; Stream &lt; <span class="lifetime">&#39;a </span>, T1 , W , N &gt; , other : &amp; N2 , source : Pipeline , tagged : bool ,) -&gt; syn :: Ident { <span class="kw">let </span>recipient_next_id = { <span class="kw">let </span><span class="kw-2">mut </span>next_id = me . next_id . borrow_mut () ; <span class="kw">let </span>id = * next_id ; * next_id += <span class="number">1 </span>; id } ; <span class="kw">let </span>ident = syn :: Ident :: new (&amp; format ! (<span class="string">&quot;stream_{}&quot; </span>, recipient_next_id) , Span :: call_site ()) ; <span class="kw">let </span><span class="kw-2">mut </span>builders_borrowed = me . builders . borrow_mut () ; <span class="kw">let </span>builders = builders_borrowed . as_mut () . unwrap () ; <span class="kw">let </span>root = get_this_crate () ; <span class="kw">let </span><span class="kw-2">mut </span>t_type : syn :: Type = syn :: parse_str (std :: any :: type_name :: &lt; T2 &gt; ()) . unwrap () ; RewriteAlloc { } . visit_type_mut (&amp; <span class="kw-2">mut </span>t_type) ; builders . entry (other . id ()) . or_default () . add_statement ({ <span class="kw">if </span>tagged { parse_quote ! { # ident = # source -&gt; map (| res | { <span class="kw">let </span>(id , b) = res . unwrap () ; (id , # root :: runtime_support :: bincode :: deserialize ::&lt;# t_type &gt; (&amp; b) . unwrap ()) }) -&gt; tee () ; } } <span class="kw">else </span>{ parse_quote ! { # ident = # source -&gt; map (| res | { # root :: runtime_support :: bincode :: deserialize ::&lt;# t_type &gt; (&amp; res . unwrap ()) . unwrap () }) -&gt; tee () ; } } }) ; ident } # [cfg (feature = <span class="string">&quot;macro&quot;</span>)] <span class="kw">impl </span>&lt; <span class="lifetime">&#39;a </span>, W , N : Location &lt; <span class="lifetime">&#39;a </span>&gt; &gt; Stream &lt; <span class="lifetime">&#39;a </span>, Bytes , W , N &gt; { <span class="kw">pub fn </span>send_bytes &lt; N2 : Location &lt; <span class="lifetime">&#39;a </span>&gt; &gt; (&amp; <span class="self">self </span>, other : &amp; N2 ,) -&gt; Stream &lt; <span class="lifetime">&#39;a </span>, <span class="prelude-ty">Result </span>&lt; BytesMut , io :: Error &gt; , Async , N2 &gt; <span class="kw">where </span>N : HfSendOneToOne &lt; <span class="lifetime">&#39;a </span>, N2 &gt; , { <span class="kw">let </span>send_port = <span class="self">self </span>. node . next_port () ; node_send_direct (<span class="self">self </span>, <span class="self">self </span>. node . gen_sink_statement (&amp; send_port)) ; <span class="kw">let </span>recv_port = other . next_port () ; <span class="kw">let </span>ident = node_recv_direct (<span class="self">self </span>, other , N :: gen_source_statement (other , &amp; recv_port)) ; <span class="self">self </span>. node . connect (other , &amp; send_port , &amp; recv_port) ; Stream { ident , node : other . clone () , next_id : <span class="self">self </span>. next_id , builders : <span class="self">self </span>. builders , is_delta : <span class="self">self </span>. is_delta , _phantom : PhantomData , } } <span class="kw">pub fn </span>send_bytes_tagged &lt; N2 : Location &lt; <span class="lifetime">&#39;a </span>&gt; &gt; (&amp; <span class="self">self </span>, other : &amp; N2 ,) -&gt; Stream &lt; <span class="lifetime">&#39;a </span>, <span class="prelude-ty">Result </span>&lt; (u32 , BytesMut) , io :: Error &gt; , Async , N2 &gt; <span class="kw">where </span>N : HfSendManyToOne &lt; <span class="lifetime">&#39;a </span>, N2 &gt; , { <span class="kw">let </span>send_port = <span class="self">self </span>. node . next_port () ; node_send_direct (<span class="self">self </span>, <span class="self">self </span>. node . gen_sink_statement (&amp; send_port)) ; <span class="kw">let </span>recv_port = other . next_port () ; <span class="kw">let </span>ident = node_recv_direct (<span class="self">self </span>, other , N :: gen_source_statement (other , &amp; recv_port)) ; <span class="self">self </span>. node . connect (other , &amp; send_port , &amp; recv_port) ; Stream { ident , node : other . clone () , next_id : <span class="self">self </span>. next_id , builders : <span class="self">self </span>. builders , is_delta : <span class="self">self </span>. is_delta , _phantom : PhantomData , } } <span class="kw">pub fn </span>send_bytes_interleaved &lt; N2 : Location &lt; <span class="lifetime">&#39;a </span>&gt; &gt; (&amp; <span class="self">self </span>, other : &amp; N2 ,) -&gt; Stream &lt; <span class="lifetime">&#39;a </span>, <span class="prelude-ty">Result </span>&lt; BytesMut , io :: Error &gt; , Async , N2 &gt; <span class="kw">where </span>N : HfSendManyToOne &lt; <span class="lifetime">&#39;a </span>, N2 &gt; , { <span class="self">self </span>. send_bytes_tagged (other) . map (q ! (| r | r . map (| (<span class="kw">_ </span>, b) | b))) } <span class="kw">pub fn </span>broadcast_bytes &lt; N2 : Location &lt; <span class="lifetime">&#39;a </span>&gt; + Cluster &lt; <span class="lifetime">&#39;a </span>&gt; &gt; (&amp; <span class="self">self </span>, other : &amp; N2 ,) -&gt; Stream &lt; <span class="lifetime">&#39;a </span>, <span class="prelude-ty">Result </span>&lt; BytesMut , io :: Error &gt; , Async , N2 &gt; <span class="kw">where </span>N : HfSendOneToMany &lt; <span class="lifetime">&#39;a </span>, N2 &gt; , { <span class="kw">let </span>other_ids = <span class="self">self </span>. node . source_iter (other . ids ()) . cloned () ; other_ids . cross_product (&amp; <span class="self">self </span>. assume_windowed ()) . demux_bytes (other) } <span class="kw">pub fn </span>broadcast_bytes_tagged &lt; N2 : Location &lt; <span class="lifetime">&#39;a </span>&gt; + Cluster &lt; <span class="lifetime">&#39;a </span>&gt; &gt; (&amp; <span class="self">self </span>, other : &amp; N2 ,) -&gt; Stream &lt; <span class="lifetime">&#39;a </span>, <span class="prelude-ty">Result </span>&lt; (u32 , BytesMut) , io :: Error &gt; , Async , N2 &gt; <span class="kw">where </span>N : HfSendManyToMany &lt; <span class="lifetime">&#39;a </span>, N2 &gt; , { <span class="kw">let </span>other_ids = <span class="self">self </span>. node . source_iter (other . ids ()) . cloned () ; other_ids . cross_product (&amp; <span class="self">self </span>. assume_windowed ()) . demux_bytes_tagged (other) } <span class="kw">pub fn </span>broadcast_bytes_interleaved &lt; N2 : Location &lt; <span class="lifetime">&#39;a </span>&gt; + Cluster &lt; <span class="lifetime">&#39;a </span>&gt; &gt; (&amp; <span class="self">self </span>, other : &amp; N2 ,) -&gt; Stream &lt; <span class="lifetime">&#39;a </span>, <span class="prelude-ty">Result </span>&lt; BytesMut , io :: Error &gt; , Async , N2 &gt; <span class="kw">where </span>N : HfSendManyToMany &lt; <span class="lifetime">&#39;a </span>, N2 &gt; , { <span class="self">self </span>. broadcast_bytes_tagged (other) . map (q ! (| r | r . map (| (<span class="kw">_ </span>, b) | b))) } } # [cfg (feature = <span class="string">&quot;macro&quot;</span>)] <span class="kw">impl </span>&lt; <span class="lifetime">&#39;a </span>, T : Serialize + DeserializeOwned , W , N : Location &lt; <span class="lifetime">&#39;a </span>&gt; &gt; Stream &lt; <span class="lifetime">&#39;a </span>, T , W , N &gt; { <span class="kw">pub fn </span>send_bincode &lt; N2 : Location &lt; <span class="lifetime">&#39;a </span>&gt; &gt; (&amp; <span class="self">self </span>, other : &amp; N2) -&gt; Stream &lt; <span class="lifetime">&#39;a </span>, T , Async , N2 &gt; <span class="kw">where </span>N : HfSendOneToOne &lt; <span class="lifetime">&#39;a </span>, N2 &gt; , { <span class="kw">let </span>send_port = <span class="self">self </span>. node . next_port () ; node_send_bincode (<span class="self">self </span>, <span class="self">self </span>. node . gen_sink_statement (&amp; send_port)) ; <span class="kw">let </span>recv_port = other . next_port () ; <span class="kw">let </span>ident = node_recv_bincode :: &lt; <span class="kw">_ </span>, T , <span class="kw">_ </span>, <span class="kw">_ </span>, <span class="kw">_ </span>&gt; (<span class="self">self </span>, other , N :: gen_source_statement (other , &amp; recv_port) , <span class="bool-val">false </span>,) ; <span class="self">self </span>. node . connect (other , &amp; send_port , &amp; recv_port) ; Stream { ident , node : other . clone () , next_id : <span class="self">self </span>. next_id , builders : <span class="self">self </span>. builders , is_delta : <span class="self">self </span>. is_delta , _phantom : PhantomData , } } <span class="kw">pub fn </span>send_bincode_tagged &lt; N2 : Location &lt; <span class="lifetime">&#39;a </span>&gt; &gt; (&amp; <span class="self">self </span>, other : &amp; N2 ,) -&gt; Stream &lt; <span class="lifetime">&#39;a </span>, (u32 , T) , Async , N2 &gt; <span class="kw">where </span>N : HfSendManyToOne &lt; <span class="lifetime">&#39;a </span>, N2 &gt; , { <span class="kw">let </span>send_port = <span class="self">self </span>. node . next_port () ; node_send_bincode (<span class="self">self </span>, <span class="self">self </span>. node . gen_sink_statement (&amp; send_port)) ; <span class="kw">let </span>recv_port = other . next_port () ; <span class="kw">let </span>ident = node_recv_bincode :: &lt; <span class="kw">_ </span>, T , <span class="kw">_ </span>, <span class="kw">_ </span>, <span class="kw">_ </span>&gt; (<span class="self">self </span>, other , N :: gen_source_statement (other , &amp; recv_port) , <span class="bool-val">true </span>,) ; <span class="self">self </span>. node . connect (other , &amp; send_port , &amp; recv_port) ; Stream { ident , node : other . clone () , next_id : <span class="self">self </span>. next_id , builders : <span class="self">self </span>. builders , is_delta : <span class="self">self </span>. is_delta , _phantom : PhantomData , } } <span class="kw">pub fn </span>send_bincode_interleaved &lt; N2 : Location &lt; <span class="lifetime">&#39;a </span>&gt; &gt; (&amp; <span class="self">self </span>, other : &amp; N2) -&gt; Stream &lt; <span class="lifetime">&#39;a </span>, T , Async , N2 &gt; <span class="kw">where </span>N : HfSendManyToOne &lt; <span class="lifetime">&#39;a </span>, N2 &gt; , { <span class="self">self </span>. send_bincode_tagged (other) . map (q ! (| (<span class="kw">_ </span>, b) | b)) } <span class="kw">pub fn </span>broadcast_bincode &lt; N2 : Location &lt; <span class="lifetime">&#39;a </span>&gt; + Cluster &lt; <span class="lifetime">&#39;a </span>&gt; &gt; (&amp; <span class="self">self </span>, other : &amp; N2 ,) -&gt; Stream &lt; <span class="lifetime">&#39;a </span>, T , Async , N2 &gt; <span class="kw">where </span>N : HfSendOneToMany &lt; <span class="lifetime">&#39;a </span>, N2 &gt; , { <span class="kw">let </span>other_ids = <span class="self">self </span>. node . source_iter (other . ids ()) . cloned () ; other_ids . cross_product (&amp; <span class="self">self </span>. assume_windowed ()) . demux_bincode (other) } <span class="kw">pub fn </span>broadcast_bincode_tagged &lt; N2 : Location &lt; <span class="lifetime">&#39;a </span>&gt; + Cluster &lt; <span class="lifetime">&#39;a </span>&gt; &gt; (&amp; <span class="self">self </span>, other : &amp; N2 ,) -&gt; Stream &lt; <span class="lifetime">&#39;a </span>, (u32 , T) , Async , N2 &gt; <span class="kw">where </span>N : HfSendManyToMany &lt; <span class="lifetime">&#39;a </span>, N2 &gt; , { <span class="kw">let </span>other_ids = <span class="self">self </span>. node . source_iter (other . ids ()) . cloned () ; other_ids . cross_product (&amp; <span class="self">self </span>. assume_windowed ()) . demux_bincode_tagged (other) } <span class="kw">pub fn </span>broadcast_bincode_interleaved &lt; N2 : Location &lt; <span class="lifetime">&#39;a </span>&gt; + Cluster &lt; <span class="lifetime">&#39;a </span>&gt; &gt; (&amp; <span class="self">self </span>, other : &amp; N2 ,) -&gt; Stream &lt; <span class="lifetime">&#39;a </span>, T , Async , N2 &gt; <span class="kw">where </span>N : HfSendManyToMany &lt; <span class="lifetime">&#39;a </span>, N2 &gt; , { <span class="self">self </span>. broadcast_bincode_tagged (other) . map (q ! (| (<span class="kw">_ </span>, b) | b)) } } # [cfg (feature = <span class="string">&quot;macro&quot;</span>)] <span class="kw">impl </span>&lt; <span class="lifetime">&#39;a </span>, W , N : Location &lt; <span class="lifetime">&#39;a </span>&gt; &gt; Stream &lt; <span class="lifetime">&#39;a </span>, (u32 , Bytes) , W , N &gt; { <span class="kw">pub fn </span>demux_bytes &lt; N2 : Location &lt; <span class="lifetime">&#39;a </span>&gt; &gt; (&amp; <span class="self">self </span>, other : &amp; N2 ,) -&gt; Stream &lt; <span class="lifetime">&#39;a </span>, <span class="prelude-ty">Result </span>&lt; BytesMut , io :: Error &gt; , Async , N2 &gt; <span class="kw">where </span>N : HfSendOneToMany &lt; <span class="lifetime">&#39;a </span>, N2 &gt; , { <span class="kw">let </span>send_port = <span class="self">self </span>. node . next_port () ; node_send_direct (<span class="self">self </span>, <span class="self">self </span>. node . gen_sink_statement (&amp; send_port)) ; <span class="kw">let </span>recv_port = other . next_port () ; <span class="kw">let </span>ident = node_recv_direct (<span class="self">self </span>, other , N :: gen_source_statement (other , &amp; recv_port)) ; <span class="self">self </span>. node . connect (other , &amp; send_port , &amp; recv_port) ; Stream { ident , node : other . clone () , next_id : <span class="self">self </span>. next_id , builders : <span class="self">self </span>. builders , is_delta : <span class="self">self </span>. is_delta , _phantom : PhantomData , } } } # [cfg (feature = <span class="string">&quot;macro&quot;</span>)] <span class="kw">impl </span>&lt; <span class="lifetime">&#39;a </span>, T : Serialize + DeserializeOwned , W , N : Location &lt; <span class="lifetime">&#39;a </span>&gt; &gt; Stream &lt; <span class="lifetime">&#39;a </span>, (u32 , T) , W , N &gt; { <span class="kw">pub fn </span>demux_bincode &lt; N2 : Location &lt; <span class="lifetime">&#39;a </span>&gt; &gt; (&amp; <span class="self">self </span>, other : &amp; N2) -&gt; Stream &lt; <span class="lifetime">&#39;a </span>, T , Async , N2 &gt; <span class="kw">where </span>N : HfSendOneToMany &lt; <span class="lifetime">&#39;a </span>, N2 &gt; , { <span class="kw">let </span>send_port = <span class="self">self </span>. node . next_port () ; cluster_demux_bincode (<span class="self">self </span>, <span class="self">self </span>. node . gen_sink_statement (&amp; send_port)) ; <span class="kw">let </span>recv_port = other . next_port () ; <span class="kw">let </span>ident = node_recv_bincode :: &lt; <span class="kw">_ </span>, T , <span class="kw">_ </span>, <span class="kw">_ </span>, <span class="kw">_ </span>&gt; (<span class="self">self </span>, other , N :: gen_source_statement (other , &amp; recv_port) , <span class="bool-val">false </span>,) ; <span class="self">self </span>. node . connect (other , &amp; send_port , &amp; recv_port) ; Stream { ident , node : other . clone () , next_id : <span class="self">self </span>. next_id , builders : <span class="self">self </span>. builders , is_delta : <span class="self">self </span>. is_delta , _phantom : PhantomData , } } } # [cfg (feature = <span class="string">&quot;macro&quot;</span>)] <span class="kw">impl </span>&lt; <span class="lifetime">&#39;a </span>, W , N : Location &lt; <span class="lifetime">&#39;a </span>&gt; &gt; Stream &lt; <span class="lifetime">&#39;a </span>, (u32 , Bytes) , W , N &gt; { <span class="kw">pub fn </span>demux_bytes_tagged &lt; N2 : Location &lt; <span class="lifetime">&#39;a </span>&gt; &gt; (&amp; <span class="self">self </span>, other : &amp; N2 ,) -&gt; Stream &lt; <span class="lifetime">&#39;a </span>, <span class="prelude-ty">Result </span>&lt; (u32 , BytesMut) , io :: Error &gt; , Async , N2 &gt; <span class="kw">where </span>N : HfSendManyToMany &lt; <span class="lifetime">&#39;a </span>, N2 &gt; , { <span class="kw">let </span>send_port = <span class="self">self </span>. node . next_port () ; node_send_direct (<span class="self">self </span>, <span class="self">self </span>. node . gen_sink_statement (&amp; send_port)) ; <span class="kw">let </span>recv_port = other . next_port () ; <span class="kw">let </span>ident = node_recv_direct (<span class="self">self </span>, other , N :: gen_source_statement (other , &amp; recv_port)) ; <span class="self">self </span>. node . connect (other , &amp; send_port , &amp; recv_port) ; Stream { ident , node : other . clone () , next_id : <span class="self">self </span>. next_id , builders : <span class="self">self </span>. builders , is_delta : <span class="self">self </span>. is_delta , _phantom : PhantomData , } } <span class="kw">pub fn </span>demux_bytes_interleaved &lt; N2 : Location &lt; <span class="lifetime">&#39;a </span>&gt; &gt; (&amp; <span class="self">self </span>, other : &amp; N2 ,) -&gt; Stream &lt; <span class="lifetime">&#39;a </span>, <span class="prelude-ty">Result </span>&lt; BytesMut , io :: Error &gt; , Async , N2 &gt; <span class="kw">where </span>N : HfSendManyToMany &lt; <span class="lifetime">&#39;a </span>, N2 &gt; , { <span class="self">self </span>. demux_bytes_tagged (other) . map (q ! (| r | r . map (| (<span class="kw">_ </span>, b) | b))) } } # [cfg (feature = <span class="string">&quot;macro&quot;</span>)] <span class="kw">impl </span>&lt; <span class="lifetime">&#39;a </span>, T : Serialize + DeserializeOwned , W , N : Location &lt; <span class="lifetime">&#39;a </span>&gt; &gt; Stream &lt; <span class="lifetime">&#39;a </span>, (u32 , T) , W , N &gt; { <span class="kw">pub fn </span>demux_bincode_tagged &lt; N2 : Location &lt; <span class="lifetime">&#39;a </span>&gt; &gt; (&amp; <span class="self">self </span>, other : &amp; N2 ,) -&gt; Stream &lt; <span class="lifetime">&#39;a </span>, (u32 , T) , Async , N2 &gt; <span class="kw">where </span>N : HfSendManyToMany &lt; <span class="lifetime">&#39;a </span>, N2 &gt; , { <span class="kw">let </span>send_port = <span class="self">self </span>. node . next_port () ; cluster_demux_bincode (<span class="self">self </span>, <span class="self">self </span>. node . gen_sink_statement (&amp; send_port)) ; <span class="kw">let </span>recv_port = other . next_port () ; <span class="kw">let </span>ident = node_recv_bincode :: &lt; <span class="kw">_ </span>, T , <span class="kw">_ </span>, <span class="kw">_ </span>, <span class="kw">_ </span>&gt; (<span class="self">self </span>, other , N :: gen_source_statement (other , &amp; recv_port) , <span class="bool-val">true </span>,) ; <span class="self">self </span>. node . connect (other , &amp; send_port , &amp; recv_port) ; Stream { ident , node : other . clone () , next_id : <span class="self">self </span>. next_id , builders : <span class="self">self </span>. builders , is_delta : <span class="self">self </span>. is_delta , _phantom : PhantomData , } } <span class="kw">pub fn </span>demux_bincode_interleaved &lt; N2 : Location &lt; <span class="lifetime">&#39;a </span>&gt; &gt; (&amp; <span class="self">self </span>, other : &amp; N2 ,) -&gt; Stream &lt; <span class="lifetime">&#39;a </span>, T , Async , N2 &gt; <span class="kw">where </span>N : HfSendManyToMany &lt; <span class="lifetime">&#39;a </span>, N2 &gt; , { <span class="self">self </span>. demux_bincode_tagged (other) . map (q ! (| (<span class="kw">_ </span>, b) | b)) } } } <span class="kw">pub use </span>stream :: Stream ; <span class="kw">pub mod </span>location { <span class="kw">pub use </span>std :: cell :: RefCell ; <span class="kw">pub use </span>std :: io ; <span class="kw">pub use </span>std :: marker :: PhantomData ; <span class="kw">pub use </span>std :: time :: Duration ; <span class="kw">pub use </span>hydroflow :: bytes :: BytesMut ; <span class="kw">pub use </span>hydroflow :: futures :: stream :: Stream <span class="kw">as </span>FuturesStream ; <span class="kw">pub use </span>proc_macro2 :: Span ; <span class="kw">pub use </span>stageleft :: { q , Quoted } ; <span class="kw">pub use </span>syn :: parse_quote ; <span class="kw">pub use crate </span>:: builder :: Builders ; <span class="kw">pub use crate </span>:: stream :: { Async , Windowed } ; <span class="kw">pub use crate </span>:: { FlowBuilder , HfCycle , Stream } ; <span class="kw">pub mod </span>graphs { <span class="kw">pub use </span>std :: cell :: RefCell ; <span class="kw">pub use </span>stageleft :: { Quoted , RuntimeData } ; <span class="kw">pub use super </span>:: { Cluster , LocalDeploy , Location , ProcessSpec } ; <span class="kw">pub use crate </span>:: builder :: Builders ; <span class="kw">pub use crate </span>:: FlowBuilder ; <span class="kw">pub use crate </span>:: location :: graphs :: SingleProcessGraph ; # [cfg (feature = <span class="string">&quot;macro&quot;</span>)] <span class="kw">impl </span>&lt; <span class="lifetime">&#39;a </span>&gt; LocalDeploy &lt; <span class="lifetime">&#39;a </span>&gt; <span class="kw">for </span>SingleProcessGraph { <span class="kw">type </span>Process = SingleNode &lt; <span class="lifetime">&#39;a </span>&gt; ; <span class="kw">type </span>Cluster = SingleNode &lt; <span class="lifetime">&#39;a </span>&gt; ; <span class="kw">type </span>Meta = () ; <span class="kw">type </span>RuntimeID = () ; } # [cfg (feature = <span class="string">&quot;macro&quot;</span>)] <span class="kw">impl </span>&lt; <span class="lifetime">&#39;a </span>&gt; ProcessSpec &lt; <span class="lifetime">&#39;a </span>, SingleProcessGraph &gt; <span class="kw">for </span>() { <span class="kw">fn </span>build (&amp; <span class="self">self </span>, _id : usize , builder : &amp; <span class="lifetime">&#39;a </span>FlowBuilder &lt; <span class="lifetime">&#39;a </span>, SingleProcessGraph &gt; , _meta : &amp; <span class="kw-2">mut </span>() ,) -&gt; SingleNode &lt; <span class="lifetime">&#39;a </span>&gt; { SingleNode { builder } } } <span class="kw">pub use crate </span>:: location :: graphs :: SingleNode ; # [cfg (feature = <span class="string">&quot;macro&quot;</span>)] <span class="kw">impl </span>&lt; <span class="lifetime">&#39;a </span>&gt; Location &lt; <span class="lifetime">&#39;a </span>&gt; <span class="kw">for </span>SingleNode &lt; <span class="lifetime">&#39;a </span>&gt; { <span class="kw">type </span>Port = () ; <span class="kw">type </span>Meta = () ; <span class="kw">fn </span>id (&amp; <span class="self">self</span>) -&gt; usize { <span class="number">0 </span>} <span class="kw">fn </span>flow_builder (&amp; <span class="self">self</span>) -&gt; (&amp; <span class="lifetime">&#39;a </span>RefCell &lt; usize &gt; , &amp; <span class="lifetime">&#39;a </span>Builders) { (&amp; <span class="self">self </span>. builder . next_id , &amp; <span class="self">self </span>. builder . builders) } <span class="kw">fn </span>next_port (&amp; <span class="self">self</span>) { panic ! () ; } <span class="kw">fn </span>update_meta (&amp; <span class="kw-2">mut </span><span class="self">self </span>, _meta : &amp; <span class="self">Self </span>:: Meta) { } } # [cfg (feature = <span class="string">&quot;macro&quot;</span>)] <span class="kw">impl </span>&lt; <span class="lifetime">&#39;a </span>&gt; Cluster &lt; <span class="lifetime">&#39;a </span>&gt; <span class="kw">for </span>SingleNode &lt; <span class="lifetime">&#39;a </span>&gt; { <span class="kw">fn </span>ids (&amp; <span class="self">self</span>) -&gt; <span class="kw">impl </span>Quoted &lt; <span class="lifetime">&#39;a </span>, &amp; <span class="lifetime">&#39;a </span>Vec &lt; u32 &gt; &gt; + Copy + <span class="lifetime">&#39;a </span>{ panic ! () ; # [allow (unreachable_code)] RuntimeData :: new (<span class="string">&quot;&quot;</span>) } } <span class="kw">pub use crate </span>:: location :: graphs :: MultiGraph ; # [cfg (feature = <span class="string">&quot;macro&quot;</span>)] <span class="kw">impl </span>&lt; <span class="lifetime">&#39;a </span>&gt; LocalDeploy &lt; <span class="lifetime">&#39;a </span>&gt; <span class="kw">for </span>MultiGraph { <span class="kw">type </span>Process = MultiNode &lt; <span class="lifetime">&#39;a </span>&gt; ; <span class="kw">type </span>Cluster = MultiNode &lt; <span class="lifetime">&#39;a </span>&gt; ; <span class="kw">type </span>Meta = () ; <span class="kw">type </span>RuntimeID = usize ; } # [cfg (feature = <span class="string">&quot;macro&quot;</span>)] <span class="kw">impl </span>&lt; <span class="lifetime">&#39;a </span>&gt; ProcessSpec &lt; <span class="lifetime">&#39;a </span>, MultiGraph &gt; <span class="kw">for </span>() { <span class="kw">fn </span>build (&amp; <span class="self">self </span>, id : usize , builder : &amp; <span class="lifetime">&#39;a </span>FlowBuilder &lt; <span class="lifetime">&#39;a </span>, MultiGraph &gt; , _meta : &amp; <span class="kw-2">mut </span>() ,) -&gt; MultiNode &lt; <span class="lifetime">&#39;a </span>&gt; { MultiNode { builder , id } } } <span class="kw">pub use crate </span>:: location :: graphs :: MultiNode ; # [cfg (feature = <span class="string">&quot;macro&quot;</span>)] <span class="kw">impl </span>&lt; <span class="lifetime">&#39;a </span>&gt; Location &lt; <span class="lifetime">&#39;a </span>&gt; <span class="kw">for </span>MultiNode &lt; <span class="lifetime">&#39;a </span>&gt; { <span class="kw">type </span>Port = () ; <span class="kw">type </span>Meta = () ; <span class="kw">fn </span>id (&amp; <span class="self">self</span>) -&gt; usize { <span class="self">self </span>. id } <span class="kw">fn </span>flow_builder (&amp; <span class="self">self</span>) -&gt; (&amp; <span class="lifetime">&#39;a </span>RefCell &lt; usize &gt; , &amp; <span class="lifetime">&#39;a </span>Builders) { (&amp; <span class="self">self </span>. builder . next_id , &amp; <span class="self">self </span>. builder . builders) } <span class="kw">fn </span>next_port (&amp; <span class="self">self</span>) { panic ! () ; } <span class="kw">fn </span>update_meta (&amp; <span class="kw-2">mut </span><span class="self">self </span>, _meta : &amp; <span class="self">Self </span>:: Meta) { } } # [cfg (feature = <span class="string">&quot;macro&quot;</span>)] <span class="kw">impl </span>&lt; <span class="lifetime">&#39;a </span>&gt; Cluster &lt; <span class="lifetime">&#39;a </span>&gt; <span class="kw">for </span>MultiNode &lt; <span class="lifetime">&#39;a </span>&gt; { <span class="kw">fn </span>ids (&amp; <span class="self">self</span>) -&gt; <span class="kw">impl </span>Quoted &lt; <span class="lifetime">&#39;a </span>, &amp; <span class="lifetime">&#39;a </span>Vec &lt; u32 &gt; &gt; + Copy + <span class="lifetime">&#39;a </span>{ panic ! () ; # [allow (unreachable_code)] RuntimeData :: new (<span class="string">&quot;&quot;</span>) } } } <span class="kw">pub use </span>graphs :: * ; <span class="kw">pub mod </span>network { <span class="kw">pub use </span>hydroflow_lang :: parse :: Pipeline ; <span class="kw">pub use super </span>:: Location ; <span class="kw">pub use crate </span>:: location :: network :: HfSendOneToOne ; <span class="kw">pub use crate </span>:: location :: network :: HfSendManyToOne ; <span class="kw">pub use crate </span>:: location :: network :: HfSendOneToMany ; <span class="kw">pub use crate </span>:: location :: network :: HfSendManyToMany ; } <span class="kw">pub use </span>network :: * ; <span class="kw">pub use crate </span>:: location :: LocalDeploy ; <span class="kw">pub use crate </span>:: location :: Deploy ; # [cfg (feature = <span class="string">&quot;macro&quot;</span>)] <span class="kw">impl </span>&lt; <span class="lifetime">&#39;a </span>, T : Deploy &lt; <span class="lifetime">&#39;a </span>, Process = N , Cluster = C , Meta = M , RuntimeID = R &gt; , N : Location &lt; <span class="lifetime">&#39;a </span>, Meta = M &gt; + HfSendOneToOne &lt; <span class="lifetime">&#39;a </span>, N &gt; + HfSendOneToMany &lt; <span class="lifetime">&#39;a </span>, C &gt; , C : Location &lt; <span class="lifetime">&#39;a </span>, Meta = M &gt; + HfSendManyToOne &lt; <span class="lifetime">&#39;a </span>, N &gt; + HfSendManyToMany &lt; <span class="lifetime">&#39;a </span>, C &gt; + Cluster &lt; <span class="lifetime">&#39;a </span>&gt; , M : Default , R , &gt; LocalDeploy &lt; <span class="lifetime">&#39;a </span>&gt; <span class="kw">for </span>T { <span class="kw">type </span>Process = N ; <span class="kw">type </span>Cluster = C ; <span class="kw">type </span>Meta = M ; <span class="kw">type </span>RuntimeID = R ; } <span class="kw">pub use crate </span>:: location :: ProcessSpec ; <span class="kw">pub use crate </span>:: location :: ClusterSpec ; <span class="kw">pub use crate </span>:: location :: Location ; <span class="kw">pub use crate </span>:: location :: Cluster ; } <span class="kw">pub use </span>location :: { Cluster , ClusterSpec , Deploy , LocalDeploy , Location , MultiGraph , ProcessSpec , SingleProcessGraph , } ; <span class="kw">pub mod </span>cycle { <span class="kw">pub use </span>std :: marker :: PhantomData ; <span class="kw">pub use </span>syn :: parse_quote ; <span class="kw">pub use crate </span>:: builder :: Builders ; <span class="kw">pub use crate </span>:: location :: Location ; <span class="kw">pub use crate </span>:: Stream ; <span class="kw">pub use crate </span>:: cycle :: HfCycle ; # [cfg (feature = <span class="string">&quot;macro&quot;</span>)] <span class="kw">impl </span>&lt; <span class="lifetime">&#39;a </span>, T , W , N : Location &lt; <span class="lifetime">&#39;a </span>&gt; &gt; HfCycle &lt; <span class="lifetime">&#39;a </span>, T , W , N &gt; { <span class="kw">pub fn </span>complete (<span class="self">self </span>, stream : &amp; Stream &lt; <span class="lifetime">&#39;a </span>, T , W , N &gt;) { <span class="kw">let </span>ident = <span class="self">self </span>. ident ; <span class="kw">let </span>stream_ident = stream . ensure_concrete () . ident . clone () ; <span class="self">self </span>. builders . borrow_mut () . as_mut () . unwrap () . entry (<span class="self">self </span>. node . id ()) . or_default () . add_statement (parse_quote ! { # stream_ident -&gt; # ident ; }) ; } } } <span class="kw">pub use </span>cycle :: HfCycle ; <span class="kw">pub mod </span>builder { <span class="kw">pub use </span>std :: cell :: RefCell ; <span class="kw">pub use </span>std :: collections :: BTreeMap ; <span class="kw">pub use </span>std :: marker :: PhantomData ; <span class="kw">pub use </span>hydroflow_lang :: graph :: { eliminate_extra_unions_tees , partition_graph , propagate_flow_props , FlatGraphBuilder , } ; <span class="kw">pub use </span>proc_macro2 :: { Span , TokenStream } ; <span class="kw">pub use </span>quote :: quote ; <span class="kw">pub use </span>stageleft :: { Quoted , QuotedContext } ; <span class="kw">pub use </span>syn :: parse_quote ; <span class="kw">pub use crate </span>:: location :: { ClusterSpec , LocalDeploy , Location , ProcessSpec } ; <span class="kw">pub use crate </span>:: { HfBuilt , RuntimeContext } ; <span class="kw">pub type </span>Builders = RefCell &lt; <span class="prelude-ty">Option </span>&lt; BTreeMap &lt; usize , FlatGraphBuilder &gt; &gt; &gt; ; <span class="kw">pub use crate </span>:: builder :: FlowBuilder ; # [cfg (feature = <span class="string">&quot;macro&quot;</span>)] <span class="kw">impl </span>&lt; <span class="lifetime">&#39;a </span>, D : LocalDeploy &lt; <span class="lifetime">&#39;a </span>&gt; &gt; QuotedContext <span class="kw">for </span>FlowBuilder &lt; <span class="lifetime">&#39;a </span>, D &gt; { <span class="kw">fn </span>create () -&gt; <span class="self">Self </span>{ FlowBuilder :: new () } } # [cfg (feature = <span class="string">&quot;macro&quot;</span>)] <span class="kw">impl </span>&lt; <span class="lifetime">&#39;a </span>, D : LocalDeploy &lt; <span class="lifetime">&#39;a </span>&gt; &gt; FlowBuilder &lt; <span class="lifetime">&#39;a </span>, D &gt; { # [allow (clippy :: new_without_default)] <span class="kw">pub fn </span>new () -&gt; FlowBuilder &lt; <span class="lifetime">&#39;a </span>, D &gt; { FlowBuilder { next_id : RefCell :: new (<span class="number">0</span>) , builders : RefCell :: new (<span class="prelude-val">Some </span>(Default :: default ())) , nodes : RefCell :: new (Vec :: new ()) , clusters : RefCell :: new (Vec :: new ()) , meta : RefCell :: new (Default :: default ()) , next_node_id : RefCell :: new (<span class="number">0</span>) , _phantom : PhantomData , } } <span class="kw">pub fn </span>builder_components (&amp; <span class="self">self</span>) -&gt; (&amp; RefCell &lt; usize &gt; , &amp; Builders) { (&amp; <span class="self">self </span>. next_id , &amp; <span class="self">self </span>. builders) } <span class="kw">pub fn </span>process (&amp; <span class="lifetime">&#39;a </span><span class="self">self </span>, spec : &amp; <span class="kw">impl </span>ProcessSpec &lt; <span class="lifetime">&#39;a </span>, D &gt;) -&gt; D :: Process { <span class="kw">let </span><span class="kw-2">mut </span>next_node_id = <span class="self">self </span>. next_node_id . borrow_mut () ; <span class="kw">let </span>id = * next_node_id ; * next_node_id += <span class="number">1 </span>; <span class="kw">let </span>node = spec . build (id , <span class="self">self </span>, &amp; <span class="kw-2">mut </span><span class="self">self </span>. meta . borrow_mut ()) ; <span class="self">self </span>. nodes . borrow_mut () . push (node . clone ()) ; <span class="self">self </span>. update_metas () ; node } <span class="kw">pub fn </span>cluster (&amp; <span class="lifetime">&#39;a </span><span class="self">self </span>, spec : &amp; <span class="kw">impl </span>ClusterSpec &lt; <span class="lifetime">&#39;a </span>, D &gt;) -&gt; D :: Cluster { <span class="kw">let </span><span class="kw-2">mut </span>next_node_id = <span class="self">self </span>. next_node_id . borrow_mut () ; <span class="kw">let </span>id = * next_node_id ; * next_node_id += <span class="number">1 </span>; <span class="kw">let </span>cluster = spec . build (id , <span class="self">self </span>, &amp; <span class="kw-2">mut </span><span class="self">self </span>. meta . borrow_mut ()) ; <span class="self">self </span>. clusters . borrow_mut () . push (cluster . clone ()) ; <span class="self">self </span>. update_metas () ; cluster } <span class="kw">pub fn </span>runtime_context (&amp; <span class="self">self</span>) -&gt; RuntimeContext &lt; <span class="lifetime">&#39;a </span>&gt; { RuntimeContext { _phantom : PhantomData , } } <span class="kw">fn </span>update_metas (&amp; <span class="self">self</span>) { <span class="self">self </span>. nodes . borrow_mut () . iter_mut () . for_each (| n | n . update_meta (&amp; <span class="self">self </span>. meta . borrow ())) ; <span class="self">self </span>. clusters . borrow_mut () . iter_mut () . for_each (| n | n . update_meta (&amp; <span class="self">self </span>. meta . borrow ())) ; } } <span class="kw">pub fn </span>build_inner &lt; <span class="lifetime">&#39;a </span>, D : LocalDeploy &lt; <span class="lifetime">&#39;a </span>&gt; &gt; (me : &amp; FlowBuilder &lt; <span class="lifetime">&#39;a </span>, D &gt; , id : TokenStream) -&gt; HfBuilt &lt; <span class="lifetime">&#39;a </span>&gt; { <span class="kw">let </span>builders = me . builders . borrow_mut () . take () . unwrap () ; <span class="kw">let </span><span class="kw-2">mut </span>conditioned_tokens = <span class="prelude-val">None </span>; <span class="kw">for </span>(subgraph_id , builder) <span class="kw">in </span>builders { <span class="kw">let </span>(<span class="kw-2">mut </span>flat_graph , <span class="kw">_ </span>, <span class="kw">_</span>) = builder . build () ; eliminate_extra_unions_tees (&amp; <span class="kw-2">mut </span>flat_graph) ; <span class="kw">let </span><span class="kw-2">mut </span>partitioned_graph = partition_graph (flat_graph) . expect (<span class="string">&quot;Failed to partition (cycle detected).&quot;</span>) ; <span class="kw">let </span>hydroflow_crate = proc_macro_crate :: crate_name (<span class="string">&quot;hydroflow_plus&quot;</span>) . expect (<span class="string">&quot;hydroflow_plus should be present in `Cargo.toml`&quot;</span>) ; <span class="kw">let </span>root = <span class="kw">match </span>hydroflow_crate { proc_macro_crate :: FoundCrate :: Itself =&gt; quote ! { hydroflow_plus } , proc_macro_crate :: FoundCrate :: Name (name) =&gt; { <span class="kw">let </span>ident = syn :: Ident :: new (&amp; name , Span :: call_site ()) ; quote ! { # ident } } } ; <span class="kw">let </span><span class="kw-2">mut </span>diagnostics = Vec :: new () ; <span class="kw">let _ </span>= propagate_flow_props :: propagate_flow_props (&amp; <span class="kw-2">mut </span>partitioned_graph , &amp; <span class="kw-2">mut </span>diagnostics) ; <span class="kw">let </span>tokens = partitioned_graph . as_code (&amp; root , <span class="bool-val">true </span>, quote :: quote ! () , &amp; <span class="kw-2">mut </span>diagnostics) ; <span class="kw">if let </span><span class="prelude-val">Some </span>(conditioned_tokens) = conditioned_tokens . as_mut () { * conditioned_tokens = parse_quote ! { # conditioned_tokens <span class="kw">else if </span>__given_id == # subgraph_id { # tokens } } ; } <span class="kw">else </span>{ conditioned_tokens = <span class="prelude-val">Some </span>(parse_quote ! { <span class="kw">if </span>__given_id == # subgraph_id { # tokens } }) ; } } <span class="kw">let </span>conditioned_tokens : TokenStream = conditioned_tokens . unwrap () ; HfBuilt { tokens : parse_quote ! { <span class="kw">let </span>__given_id = # id ; # conditioned_tokens <span class="kw">else </span>{ panic ! (<span class="string">&quot;Invalid node id: {}&quot; </span>, __given_id) ; } } , _phantom : PhantomData , } } # [cfg (feature = <span class="string">&quot;macro&quot;</span>)] <span class="kw">impl </span>&lt; <span class="lifetime">&#39;a </span>, D : LocalDeploy &lt; <span class="lifetime">&#39;a </span>, RuntimeID = usize &gt; &gt; FlowBuilder &lt; <span class="lifetime">&#39;a </span>, D &gt; { <span class="kw">pub fn </span>build (&amp; <span class="self">self </span>, id : <span class="kw">impl </span>Quoted &lt; <span class="lifetime">&#39;a </span>, usize &gt;) -&gt; HfBuilt &lt; <span class="lifetime">&#39;a </span>&gt; { build_inner (<span class="self">self </span>, id . splice ()) } } # [cfg (feature = <span class="string">&quot;macro&quot;</span>)] <span class="kw">impl </span>&lt; <span class="lifetime">&#39;a </span>, D : LocalDeploy &lt; <span class="lifetime">&#39;a </span>, RuntimeID = () &gt; &gt; FlowBuilder &lt; <span class="lifetime">&#39;a </span>, D &gt; { <span class="kw">pub fn </span>build_single (&amp; <span class="self">self</span>) -&gt; HfBuilt &lt; <span class="lifetime">&#39;a </span>&gt; { <span class="kw">if </span><span class="self">self </span>. builders . borrow () . as_ref () . unwrap () . len () != <span class="number">1 </span>{ panic ! (<span class="string">&quot;Expected exactly one node in the graph.&quot;</span>) ; } build_inner (<span class="self">self </span>, quote ! (<span class="number">0</span>)) } } } <span class="kw">pub use </span>builder :: FlowBuilder ; <span class="kw">pub use crate </span>:: RuntimeContext ; # [cfg (feature = <span class="string">&quot;macro&quot;</span>)] <span class="kw">impl </span>Copy <span class="kw">for </span>RuntimeContext &lt; <span class="lifetime">&#39;_ </span>&gt; { } # [cfg (feature = <span class="string">&quot;macro&quot;</span>)] <span class="kw">impl </span>&lt; <span class="lifetime">&#39;a </span>&gt; FreeVariable &lt; &amp; <span class="lifetime">&#39;a </span>Context &gt; <span class="kw">for </span>RuntimeContext &lt; <span class="lifetime">&#39;a </span>&gt; { <span class="kw">fn </span>to_tokens (<span class="self">self</span>) -&gt; (<span class="prelude-ty">Option </span>&lt; TokenStream &gt; , <span class="prelude-ty">Option </span>&lt; TokenStream &gt;) { (<span class="prelude-val">None </span>, <span class="prelude-val">Some </span>(quote ! (&amp; context))) } } <span class="kw">pub use crate </span>:: HfBuilt ; # [cfg (feature = <span class="string">&quot;macro&quot;</span>)] <span class="kw">impl </span>&lt; <span class="lifetime">&#39;a </span>&gt; Quoted &lt; <span class="lifetime">&#39;a </span>, Hydroflow &lt; <span class="lifetime">&#39;a </span>&gt; &gt; <span class="kw">for </span>HfBuilt &lt; <span class="lifetime">&#39;a </span>&gt; { } # [cfg (feature = <span class="string">&quot;macro&quot;</span>)] <span class="kw">impl </span>&lt; <span class="lifetime">&#39;a </span>&gt; FreeVariable &lt; Hydroflow &lt; <span class="lifetime">&#39;a </span>&gt; &gt; <span class="kw">for </span>HfBuilt &lt; <span class="lifetime">&#39;a </span>&gt; { <span class="kw">fn </span>to_tokens (<span class="self">self</span>) -&gt; (<span class="prelude-ty">Option </span>&lt; TokenStream &gt; , <span class="prelude-ty">Option </span>&lt; TokenStream &gt;) { (<span class="prelude-val">None </span>, <span class="prelude-val">Some </span>(<span class="self">self </span>. tokens)) } }</code></pre></div></section></main></body></html>