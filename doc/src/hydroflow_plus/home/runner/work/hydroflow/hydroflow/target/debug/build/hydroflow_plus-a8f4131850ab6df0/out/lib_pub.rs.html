<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `/home/runner/work/hydroflow/hydroflow/target/debug/build/hydroflow_plus-a8f4131850ab6df0/out/lib_pub.rs`."><title>lib_pub.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../../../../../../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../../../../../../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../../../../../../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../../../../../../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../../../../../../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../../../../../../../../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../../../../../../../../../../static.files/rustdoc-e935ef01ae1c1829.css"><meta name="rustdoc-vars" data-root-path="../../../../../../../../../../../../" data-static-root-path="../../../../../../../../../../../../static.files/" data-current-crate="hydroflow_plus" data-themes="" data-resource-suffix="" data-rustdoc-version="1.78.0-nightly (8f359beca 2024-02-23)" data-channel="nightly" data-search-js="search-dd67cee4cfa65049.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../../../../../../../../../../../static.files/storage-4c98445ec4002617.js"></script><script defer src="../../../../../../../../../../../../static.files/src-script-e66d777a5a92e9b2.js"></script><script defer src="../../../../../../../../../../../../src-files.js"></script><script defer src="../../../../../../../../../../../../static.files/main-c37d3936c59ababd.js"></script><noscript><link rel="stylesheet" href="../../../../../../../../../../../../static.files/noscript-04d5337699b92874.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../../../../../../../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../../../../../../../../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../../../../../../../../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc src"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="src-sidebar-title">
            <h2>Files</h2></div></nav><div class="sidebar-resizer"></div>
    <main><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../../../../../../../../../../../../hydroflow_plus/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../../../../../../../../../../../../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../../../../../../../../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../../../../../../../../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="example-wrap"><div data-nosnippet><pre class="src-line-numbers"><a href="#1" id="1">1</a>
</pre></div><pre class="rust"><code><span class="kw">pub use </span>std :: marker :: PhantomData ; <span class="kw">pub use </span>hydroflow :: scheduled :: context :: Context ; <span class="kw">pub use </span>hydroflow :: scheduled :: graph :: Hydroflow ; <span class="kw">pub use </span>hydroflow :: * ; <span class="kw">pub use </span>proc_macro2 :: TokenStream ; <span class="kw">pub use </span>quote :: quote ; <span class="kw">pub use </span>stageleft :: runtime_support :: FreeVariable ; <span class="kw">pub use </span>stageleft :: Quoted ; <span class="kw">pub mod </span>runtime_support { <span class="kw">pub use </span>bincode ; } <span class="kw">pub mod </span>stream { <span class="kw">pub use </span>std :: cell :: RefCell ; <span class="kw">pub use </span>std :: hash :: Hash ; <span class="kw">pub use </span>std :: marker :: PhantomData ; <span class="kw">pub use </span>std :: ops :: Deref ; <span class="kw">pub use </span>std :: rc :: Rc ; <span class="kw">pub use </span>hydroflow :: bytes :: Bytes ; <span class="kw">pub use </span>hydroflow :: futures :: Sink ; <span class="kw">pub use </span>hydroflow_lang :: parse :: Pipeline ; <span class="kw">pub use </span>proc_macro2 :: { Span , TokenStream } ; <span class="kw">pub use </span>quote :: quote ; <span class="kw">pub use </span>serde :: de :: DeserializeOwned ; <span class="kw">pub use </span>serde :: Serialize ; <span class="kw">pub use </span>stageleft :: { q , IntoQuotedMut , Quoted } ; <span class="kw">pub use </span>syn :: parse_quote ; <span class="kw">pub use </span>syn :: visit_mut :: VisitMut ; <span class="kw">pub use crate </span>:: ir :: { DebugPipelineFn , HfPlusLeaf , HfPlusNode } ; <span class="kw">pub use crate </span>:: location :: { Cluster , HfSend , Location } ; <span class="kw">pub use crate </span>:: stream :: Async ; <span class="kw">pub use crate </span>:: stream :: Windowed ; <span class="kw">pub use crate </span>:: stream :: Stream ; # [cfg (feature = <span class="string">"macro"</span>)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , W , N : Location &lt; <span class="lifetime">'a </span>&gt; &gt; Stream &lt; <span class="lifetime">'a </span>, T , W , N &gt; { <span class="kw">pub </span>(<span class="kw">crate</span>) <span class="kw">fn </span>new (node : N , ir_leaves : &amp; <span class="lifetime">'a </span>RefCell &lt; Vec &lt; HfPlusLeaf &gt; &gt; , ir_node : HfPlusNode ,) -&gt; <span class="self">Self </span>{ Stream { node , ir_leaves , ir_node : RefCell :: new (ir_node) , _phantom : PhantomData , } } } # [cfg (feature = <span class="string">"macro"</span>)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T : Clone , W , N : Location &lt; <span class="lifetime">'a </span>&gt; &gt; Clone <span class="kw">for </span>Stream &lt; <span class="lifetime">'a </span>, T , W , N &gt; { <span class="kw">fn </span>clone (&amp; <span class="self">self</span>) -&gt; <span class="self">Self </span>{ <span class="kw">if </span>! matches ! (<span class="self">self </span>. ir_node . borrow () . deref () , HfPlusNode :: Tee { .. }) { <span class="kw">let </span>orig_ir_node = <span class="self">self </span>. ir_node . replace (HfPlusNode :: Placeholder) ; * <span class="self">self </span>. ir_node . borrow_mut () = HfPlusNode :: Tee { inner : Rc :: new (RefCell :: new (orig_ir_node)) , } ; } Stream :: new (<span class="self">self </span>. node . clone () , <span class="self">self </span>. ir_leaves , <span class="self">self </span>. ir_node . borrow () . clone () ,) } } # [cfg (feature = <span class="string">"macro"</span>)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , W , N : Location &lt; <span class="lifetime">'a </span>&gt; &gt; Stream &lt; <span class="lifetime">'a </span>, T , W , N &gt; { <span class="kw">fn </span>pipeline_op &lt; U , W2 &gt; (<span class="self">self </span>, kind : &amp; <span class="lifetime">'static </span>str , gen_pipeline : <span class="kw">impl </span>Fn (bool) -&gt; <span class="prelude-ty">Option </span>&lt; (Pipeline , bool) &gt; + <span class="lifetime">'static </span>,) -&gt; Stream &lt; <span class="lifetime">'a </span>, U , W2 , N &gt; { Stream :: new (<span class="self">self </span>. node , <span class="self">self </span>. ir_leaves , HfPlusNode :: PipelineOp { kind , gen_pipeline : DebugPipelineFn (Rc :: new (gen_pipeline)) , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>map &lt; U , F : Fn (T) -&gt; U + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F &gt;) -&gt; Stream &lt; <span class="lifetime">'a </span>, U , W , N &gt; { Stream :: new (<span class="self">self </span>. node , <span class="self">self </span>. ir_leaves , HfPlusNode :: Map { f : f . splice () . into () , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>flat_map &lt; U , I : IntoIterator &lt; Item = U &gt; , F : Fn (T) -&gt; I + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F &gt; ,) -&gt; Stream &lt; <span class="lifetime">'a </span>, U , W , N &gt; { <span class="kw">let </span>f = f . splice () ; <span class="self">self </span>. pipeline_op (<span class="string">"flat_map" </span>, <span class="kw">move </span>| d | <span class="prelude-val">Some </span>((parse_quote ! (flat_map (# f)) , d))) } <span class="kw">pub fn </span>enumerate (<span class="self">self</span>) -&gt; Stream &lt; <span class="lifetime">'a </span>, (usize , T) , W , N &gt; { <span class="self">self </span>. pipeline_op (<span class="string">"enumerate" </span>, | d | { <span class="kw">if </span>d { <span class="prelude-val">None </span>} <span class="kw">else </span>{ <span class="prelude-val">Some </span>((parse_quote ! (enumerate ()) , <span class="bool-val">false</span>)) } }) } <span class="kw">pub fn </span>inspect &lt; F : Fn (&amp; T) + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F &gt;) -&gt; Stream &lt; <span class="lifetime">'a </span>, T , W , N &gt; { <span class="kw">let </span>f = f . splice () ; <span class="self">self </span>. pipeline_op (<span class="string">"inspect" </span>, <span class="kw">move </span>| d | { <span class="kw">if </span>d { <span class="prelude-val">None </span>} <span class="kw">else </span>{ <span class="prelude-val">Some </span>((parse_quote ! (inspect (# f)) , <span class="bool-val">false</span>)) } }) } <span class="kw">pub fn </span>filter &lt; F : Fn (&amp; T) -&gt; bool + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F &gt; ,) -&gt; Stream &lt; <span class="lifetime">'a </span>, T , W , N &gt; { <span class="kw">let </span>f = f . splice () ; <span class="self">self </span>. pipeline_op (<span class="string">"filter" </span>, <span class="kw">move </span>| d | <span class="prelude-val">Some </span>((parse_quote ! (filter (# f)) , d))) } <span class="kw">pub fn </span>filter_map &lt; U , F : Fn (T) -&gt; <span class="prelude-ty">Option </span>&lt; U &gt; + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F &gt; ,) -&gt; Stream &lt; <span class="lifetime">'a </span>, U , W , N &gt; { <span class="kw">let </span>f = f . splice () ; <span class="self">self </span>. pipeline_op (<span class="string">"filter_map" </span>, <span class="kw">move </span>| d | { <span class="prelude-val">Some </span>((parse_quote ! (filter_map (# f)) , d)) }) } <span class="kw">pub fn </span>cross_product &lt; O &gt; (<span class="self">self </span>, other : Stream &lt; <span class="lifetime">'a </span>, O , W , N &gt;) -&gt; Stream &lt; <span class="lifetime">'a </span>, (T , O) , W , N &gt; { <span class="kw">if </span><span class="self">self </span>. node . id () != other . node . id () { panic ! (<span class="string">"cross_product must be called on streams on the same node"</span>) ; } Stream :: new (<span class="self">self </span>. node , <span class="self">self </span>. ir_leaves , HfPlusNode :: CrossProduct (Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , Box :: new (other . ir_node . into_inner ()) ,) ,) } <span class="kw">pub fn </span>union (<span class="self">self </span>, other : Stream &lt; <span class="lifetime">'a </span>, T , W , N &gt;) -&gt; Stream &lt; <span class="lifetime">'a </span>, T , W , N &gt; { <span class="kw">if </span><span class="self">self </span>. node . id () != other . node . id () { panic ! (<span class="string">"union must be called on streams on the same node"</span>) ; } Stream :: new (<span class="self">self </span>. node , <span class="self">self </span>. ir_leaves , HfPlusNode :: Union (Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , Box :: new (other . ir_node . into_inner ()) ,) ,) } <span class="kw">pub fn </span>for_each &lt; F : Fn (T) + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F &gt;) { <span class="self">self </span>. ir_leaves . borrow_mut () . push (HfPlusLeaf :: ForEach { input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , f : f . splice () . into () , }) ; } <span class="kw">pub fn </span>dest_sink &lt; S : Unpin + Sink &lt; T &gt; + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, sink : <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, S &gt;) { <span class="self">self </span>. ir_leaves . borrow_mut () . push (HfPlusLeaf :: DestSink { sink : sink . splice () . into () , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , }) ; } <span class="kw">pub fn </span>all_ticks (<span class="self">self</span>) -&gt; Stream &lt; <span class="lifetime">'a </span>, T , Windowed , N &gt; { Stream :: new (<span class="self">self </span>. node , <span class="self">self </span>. ir_leaves , HfPlusNode :: Persist (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } <span class="kw">pub fn </span>assume_windowed (<span class="self">self</span>) -&gt; Stream &lt; <span class="lifetime">'a </span>, T , Windowed , N &gt; { Stream :: new (<span class="self">self </span>. node , <span class="self">self </span>. ir_leaves , <span class="self">self </span>. ir_node . into_inner ()) } } # [cfg (feature = <span class="string">"macro"</span>)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , N : Location &lt; <span class="lifetime">'a </span>&gt; &gt; Stream &lt; <span class="lifetime">'a </span>, T , Async , N &gt; { <span class="kw">pub fn </span>tick_batch (<span class="self">self</span>) -&gt; Stream &lt; <span class="lifetime">'a </span>, T , Windowed , N &gt; { Stream :: new (<span class="self">self </span>. node , <span class="self">self </span>. ir_leaves , <span class="self">self </span>. ir_node . into_inner ()) } } # [cfg (feature = <span class="string">"macro"</span>)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , N : Location &lt; <span class="lifetime">'a </span>&gt; &gt; Stream &lt; <span class="lifetime">'a </span>, T , Windowed , N &gt; { <span class="kw">pub fn </span>fold &lt; A , I : Fn () -&gt; A + <span class="lifetime">'a </span>, C : Fn (&amp; <span class="kw-2">mut </span>A , T) &gt; (<span class="self">self </span>, init : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, I &gt; , comb : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, C &gt; ,) -&gt; Stream &lt; <span class="lifetime">'a </span>, A , Windowed , N &gt; { <span class="kw">let </span>init = init . splice () ; <span class="kw">let </span>comb = comb . splice () ; <span class="self">self </span>. pipeline_op (<span class="string">"fold" </span>, <span class="kw">move </span>| d | { <span class="kw">if </span>d { <span class="prelude-val">Some </span>((parse_quote ! (fold ::&lt;<span class="lifetime">'static </span>&gt; (# init , # comb)) , <span class="bool-val">false</span>)) } <span class="kw">else </span>{ <span class="prelude-val">Some </span>((parse_quote ! (fold ::&lt;<span class="lifetime">'tick </span>&gt; (# init , # comb)) , <span class="bool-val">false</span>)) } }) } <span class="kw">pub fn </span>reduce &lt; C : Fn (&amp; <span class="kw-2">mut </span>T , T) + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, comb : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, C &gt; ,) -&gt; Stream &lt; <span class="lifetime">'a </span>, T , Windowed , N &gt; { <span class="kw">let </span>comb = comb . splice () ; <span class="self">self </span>. pipeline_op (<span class="string">"reduce" </span>, <span class="kw">move </span>| d | { <span class="kw">if </span>d { <span class="prelude-val">Some </span>((parse_quote ! (reduce ::&lt;<span class="lifetime">'static </span>&gt; (# comb)) , <span class="bool-val">false</span>)) } <span class="kw">else </span>{ <span class="prelude-val">Some </span>((parse_quote ! (reduce ::&lt;<span class="lifetime">'tick </span>&gt; (# comb)) , <span class="bool-val">false</span>)) } }) } <span class="kw">pub fn </span>count (<span class="self">self</span>) -&gt; Stream &lt; <span class="lifetime">'a </span>, usize , Windowed , N &gt; { <span class="self">self </span>. fold (q ! (|| <span class="number">0usize</span>) , q ! (| count , <span class="kw">_ </span>| * count += <span class="number">1</span>)) } <span class="kw">pub fn </span>delta (<span class="self">self</span>) -&gt; Stream &lt; <span class="lifetime">'a </span>, T , Windowed , N &gt; { Stream :: new (<span class="self">self </span>. node , <span class="self">self </span>. ir_leaves , HfPlusNode :: Delta (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } <span class="kw">pub fn </span>unique (<span class="self">self</span>) -&gt; Stream &lt; <span class="lifetime">'a </span>, T , Windowed , N &gt; <span class="kw">where </span>T : Eq + Hash , { <span class="self">self </span>. pipeline_op (<span class="string">"unique" </span>, | d | { <span class="kw">if </span>d { <span class="prelude-val">None </span>} <span class="kw">else </span>{ <span class="prelude-val">Some </span>((parse_quote ! (unique ::&lt;<span class="lifetime">'tick </span>&gt; ()) , <span class="bool-val">false</span>)) } }) } <span class="kw">pub fn </span>filter_not_in (<span class="self">self </span>, other : Stream &lt; <span class="lifetime">'a </span>, T , Windowed , N &gt;) -&gt; Stream &lt; <span class="lifetime">'a </span>, T , Windowed , N &gt; <span class="kw">where </span>T : Eq + Hash , { <span class="kw">if </span><span class="self">self </span>. node . id () != other . node . id () { panic ! (<span class="string">"union must be called on streams on the same node"</span>) ; } Stream :: new (<span class="self">self </span>. node , <span class="self">self </span>. ir_leaves , HfPlusNode :: Difference (Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , Box :: new (other . ir_node . into_inner ()) ,) ,) } <span class="kw">pub fn </span>sample_every (<span class="self">self </span>, duration : <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, std :: time :: Duration &gt; + Copy + <span class="lifetime">'a </span>,) -&gt; Stream &lt; <span class="lifetime">'a </span>, T , Windowed , N &gt; { <span class="kw">let </span>samples = <span class="self">self </span>. node . source_interval (duration) . tick_batch () ; <span class="self">self </span>. cross_product (samples) . map (q ! (| (a , <span class="kw">_</span>) | a)) } } # [cfg (feature = <span class="string">"macro"</span>)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T : Clone , W , N : Location &lt; <span class="lifetime">'a </span>&gt; &gt; Stream &lt; <span class="lifetime">'a </span>, &amp; T , W , N &gt; { <span class="kw">pub fn </span>cloned (<span class="self">self</span>) -&gt; Stream &lt; <span class="lifetime">'a </span>, T , W , N &gt; { <span class="self">self </span>. pipeline_op (<span class="string">"cloned" </span>, | d | <span class="prelude-val">Some </span>((parse_quote ! (map (| d | d . clone ())) , d))) } } # [cfg (feature = <span class="string">"macro"</span>)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, K , V1 , W , N : Location &lt; <span class="lifetime">'a </span>&gt; &gt; Stream &lt; <span class="lifetime">'a </span>, (K , V1) , W , N &gt; { <span class="kw">pub fn </span>join &lt; W2 , V2 &gt; (<span class="self">self </span>, n : Stream &lt; <span class="lifetime">'a </span>, (K , V2) , W2 , N &gt;) -&gt; Stream &lt; <span class="lifetime">'a </span>, (K , (V1 , V2)) , W , N &gt; <span class="kw">where </span>K : Eq + Hash , { <span class="kw">if </span><span class="self">self </span>. node . id () != n . node . id () { panic ! (<span class="string">"join must be called on streams on the same node"</span>) ; } Stream :: new (<span class="self">self </span>. node , <span class="self">self </span>. ir_leaves , HfPlusNode :: Join (Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , Box :: new (n . ir_node . into_inner ()) ,) ,) } <span class="kw">pub fn </span>anti_join &lt; W2 &gt; (<span class="self">self </span>, n : Stream &lt; <span class="lifetime">'a </span>, K , W2 , N &gt;) -&gt; Stream &lt; <span class="lifetime">'a </span>, (K , V1) , W , N &gt; <span class="kw">where </span>K : Eq + Hash , { <span class="kw">if </span><span class="self">self </span>. node . id () != n . node . id () { panic ! (<span class="string">"anti_join must be called on streams on the same node"</span>) ; } Stream :: new (<span class="self">self </span>. node , <span class="self">self </span>. ir_leaves , HfPlusNode :: AntiJoin (Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , Box :: new (n . ir_node . into_inner ()) ,) ,) } } # [cfg (feature = <span class="string">"macro"</span>)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, K : Eq + Hash , V , N : Location &lt; <span class="lifetime">'a </span>&gt; &gt; Stream &lt; <span class="lifetime">'a </span>, (K , V) , Windowed , N &gt; { <span class="kw">pub fn </span>fold_keyed &lt; A , I : Fn () -&gt; A + <span class="lifetime">'a </span>, C : Fn (&amp; <span class="kw-2">mut </span>A , V) + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, init : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, I &gt; , comb : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, C &gt; ,) -&gt; Stream &lt; <span class="lifetime">'a </span>, (K , A) , Windowed , N &gt; { <span class="kw">let </span>init = init . splice () ; <span class="kw">let </span>comb = comb . splice () ; <span class="self">self </span>. pipeline_op (<span class="string">"fold_keyed" </span>, <span class="kw">move </span>| d | { <span class="kw">if </span>d { <span class="prelude-val">Some </span>((parse_quote ! (fold_keyed ::&lt;<span class="lifetime">'static </span>&gt; (# init , # comb)) , <span class="bool-val">false</span>)) } <span class="kw">else </span>{ <span class="prelude-val">Some </span>((parse_quote ! (fold_keyed ::&lt;<span class="lifetime">'tick </span>&gt; (# init , # comb)) , <span class="bool-val">false</span>)) } }) } <span class="kw">pub fn </span>reduce_keyed &lt; F : Fn (&amp; <span class="kw-2">mut </span>V , V) + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, comb : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F &gt; ,) -&gt; Stream &lt; <span class="lifetime">'a </span>, (K , V) , Windowed , N &gt; { <span class="kw">let </span>comb = comb . splice () ; <span class="self">self </span>. pipeline_op (<span class="string">"reduce_keyed" </span>, <span class="kw">move </span>| d | { <span class="kw">if </span>d { <span class="prelude-val">Some </span>((parse_quote ! (reduce_keyed ::&lt;<span class="lifetime">'static </span>&gt; (# comb)) , <span class="bool-val">false</span>)) } <span class="kw">else </span>{ <span class="prelude-val">Some </span>((parse_quote ! (reduce_keyed ::&lt;<span class="lifetime">'tick </span>&gt; (# comb)) , <span class="bool-val">false</span>)) } }) } } <span class="kw">pub fn </span>get_this_crate () -&gt; TokenStream { <span class="kw">let </span>hydroflow_crate = proc_macro_crate :: crate_name (<span class="string">"hydroflow_plus"</span>) . expect (<span class="string">"hydroflow_plus should be present in `Cargo.toml`"</span>) ; <span class="kw">match </span>hydroflow_crate { proc_macro_crate :: FoundCrate :: Itself =&gt; quote ! { hydroflow_plus } , proc_macro_crate :: FoundCrate :: Name (name) =&gt; { <span class="kw">let </span>ident = syn :: Ident :: new (&amp; name , Span :: call_site ()) ; quote ! { # ident } } } } <span class="kw">pub use crate </span>:: stream :: RewriteAlloc ; # [cfg (feature = <span class="string">"macro"</span>)] <span class="kw">impl </span>VisitMut <span class="kw">for </span>RewriteAlloc { <span class="kw">fn </span>visit_path_mut (&amp; <span class="kw-2">mut </span><span class="self">self </span>, i : &amp; <span class="kw-2">mut </span>syn :: Path) { <span class="kw">if </span>i . segments . iter () . take (<span class="number">2</span>) . collect :: &lt; Vec &lt; <span class="kw">_ </span>&gt; &gt; () == vec ! [&amp; syn :: PathSegment :: from (syn :: Ident :: new (<span class="string">"alloc" </span>, Span :: call_site ())) , &amp; syn :: PathSegment :: from (syn :: Ident :: new (<span class="string">"string" </span>, Span :: call_site ())) ,] { * i . segments . first_mut () . unwrap () = syn :: PathSegment :: from (syn :: Ident :: new (<span class="string">"std" </span>, Span :: call_site ())) ; } } } <span class="kw">pub fn </span>serialize_bincode &lt; T : Serialize &gt; (is_demux : bool) -&gt; Pipeline { <span class="kw">let </span>root = get_this_crate () ; <span class="kw">let </span><span class="kw-2">mut </span>t_type : syn :: Type = syn :: parse_str (std :: any :: type_name :: &lt; T &gt; ()) . unwrap () ; RewriteAlloc { } . visit_type_mut (&amp; <span class="kw-2">mut </span>t_type) ; <span class="kw">if </span>is_demux { parse_quote ! { map (| (id , data) | { (id , # root :: runtime_support :: bincode :: serialize ::&lt;# t_type &gt; (&amp; data) . unwrap () . into ()) }) } } <span class="kw">else </span>{ parse_quote ! { map (| data | { # root :: runtime_support :: bincode :: serialize ::&lt;# t_type &gt; (&amp; data) . unwrap () . into () }) } } } <span class="kw">pub fn </span>deserialize_bincode &lt; T2 : DeserializeOwned &gt; (tagged : bool) -&gt; Pipeline { <span class="kw">let </span>root = get_this_crate () ; <span class="kw">let </span><span class="kw-2">mut </span>t_type : syn :: Type = syn :: parse_str (std :: any :: type_name :: &lt; T2 &gt; ()) . unwrap () ; RewriteAlloc { } . visit_type_mut (&amp; <span class="kw-2">mut </span>t_type) ; <span class="kw">if </span>tagged { parse_quote ! { map (| res | { <span class="kw">let </span>(id , b) = res . unwrap () ; (id , # root :: runtime_support :: bincode :: deserialize ::&lt;# t_type &gt; (&amp; b) . unwrap ()) }) } } <span class="kw">else </span>{ parse_quote ! { map (| res | { # root :: runtime_support :: bincode :: deserialize ::&lt;# t_type &gt; (&amp; res . unwrap ()) . unwrap () }) } } } # [cfg (feature = <span class="string">"macro"</span>)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , W , N : Location &lt; <span class="lifetime">'a </span>&gt; &gt; Stream &lt; <span class="lifetime">'a </span>, T , W , N &gt; { <span class="kw">pub fn </span>send_bincode &lt; N2 : Location &lt; <span class="lifetime">'a </span>&gt; , V , CoreType &gt; (<span class="self">self </span>, other : &amp; N2 ,) -&gt; Stream &lt; <span class="lifetime">'a </span>, N :: Out &lt; CoreType &gt; , Async , N2 &gt; <span class="kw">where </span>N : HfSend &lt; <span class="lifetime">'a </span>, N2 , V , In &lt; CoreType &gt; = T &gt; , CoreType : Serialize + DeserializeOwned , { <span class="kw">let </span>send_port = <span class="self">self </span>. node . next_port () ; <span class="kw">let </span>serialize_pipeline = <span class="prelude-val">Some </span>(serialize_bincode :: &lt; CoreType &gt; (N :: is_demux ())) ; <span class="kw">let </span>sink_expr = <span class="self">self </span>. node . gen_sink_statement (&amp; send_port) . into () ; <span class="kw">let </span>recv_port = other . next_port () ; <span class="kw">let </span>deserialize_pipeline = <span class="prelude-val">Some </span>(deserialize_bincode :: &lt; CoreType &gt; (N :: is_tagged ())) ; <span class="kw">let </span>source_expr = N :: gen_source_statement (other , &amp; recv_port) . into () ; <span class="self">self </span>. node . connect (other , &amp; send_port , &amp; recv_port) ; Stream :: new (other . clone () , <span class="self">self </span>. ir_leaves , HfPlusNode :: Network { to_location : other . id () , serialize_pipeline , sink_expr , source_expr , deserialize_pipeline , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>send_bytes &lt; N2 : Location &lt; <span class="lifetime">'a </span>&gt; , V &gt; (<span class="self">self </span>, other : &amp; N2) -&gt; Stream &lt; <span class="lifetime">'a </span>, N :: Out &lt; Bytes &gt; , Async , N2 &gt; <span class="kw">where </span>N : HfSend &lt; <span class="lifetime">'a </span>, N2 , V , In &lt; Bytes &gt; = T &gt; , { <span class="kw">let </span>send_port = <span class="self">self </span>. node . next_port () ; <span class="kw">let </span>sink_expr = <span class="self">self </span>. node . gen_sink_statement (&amp; send_port) . into () ; <span class="kw">let </span>recv_port = other . next_port () ; <span class="kw">let </span>source_expr = N :: gen_source_statement (other , &amp; recv_port) . into () ; <span class="self">self </span>. node . connect (other , &amp; send_port , &amp; recv_port) ; Stream :: new (other . clone () , <span class="self">self </span>. ir_leaves , HfPlusNode :: Network { to_location : other . id () , serialize_pipeline : <span class="prelude-val">None </span>, sink_expr , source_expr , deserialize_pipeline : <span class="kw">if </span>N :: is_tagged () { <span class="prelude-val">Some </span>(parse_quote ! (map (| (id , b) | (id , b . unwrap () . freeze ())))) } <span class="kw">else </span>{ <span class="prelude-val">Some </span>(parse_quote ! (map (| b | b . unwrap () . freeze ()))) } , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>send_bincode_interleaved &lt; N2 : Location &lt; <span class="lifetime">'a </span>&gt; , Tag , CoreType , V &gt; (<span class="self">self </span>, other : &amp; N2 ,) -&gt; Stream &lt; <span class="lifetime">'a </span>, T , Async , N2 &gt; <span class="kw">where </span>N : HfSend &lt; <span class="lifetime">'a </span>, N2 , V , In &lt; CoreType &gt; = T , Out &lt; CoreType &gt; = (Tag , T) &gt; , CoreType : Serialize + DeserializeOwned , { <span class="self">self </span>. send_bincode :: &lt; N2 , V , CoreType &gt; (other) . map (q ! (| (<span class="kw">_ </span>, b) | b)) } <span class="kw">pub fn </span>send_bytes_interleaved &lt; N2 : Location &lt; <span class="lifetime">'a </span>&gt; , Tag , V &gt; (<span class="self">self </span>, other : &amp; N2 ,) -&gt; Stream &lt; <span class="lifetime">'a </span>, Bytes , Async , N2 &gt; <span class="kw">where </span>N : HfSend &lt; <span class="lifetime">'a </span>, N2 , V , In &lt; Bytes &gt; = T , Out &lt; Bytes &gt; = (Tag , Bytes) &gt; , { <span class="self">self </span>. send_bytes :: &lt; N2 , V &gt; (other) . map (q ! (| (<span class="kw">_ </span>, b) | b)) } <span class="kw">pub fn </span>broadcast_bincode &lt; N2 : Location &lt; <span class="lifetime">'a </span>&gt; + Cluster &lt; <span class="lifetime">'a </span>&gt; , V &gt; (<span class="self">self </span>, other : &amp; N2 ,) -&gt; Stream &lt; <span class="lifetime">'a </span>, N :: Out &lt; T &gt; , Async , N2 &gt; <span class="kw">where </span>N : HfSend &lt; <span class="lifetime">'a </span>, N2 , V , In &lt; T &gt; = (N2 :: Id , T) &gt; , T : Serialize + DeserializeOwned , N2 :: Id : Clone , { <span class="kw">let </span>other_ids = <span class="self">self </span>. node . source_iter (other . ids ()) . cloned () . all_ticks () ; other_ids . cross_product (<span class="self">self </span>. assume_windowed ()) . send_bincode (other) } <span class="kw">pub fn </span>broadcast_bincode_interleaved &lt; N2 : Location &lt; <span class="lifetime">'a </span>&gt; + Cluster &lt; <span class="lifetime">'a </span>&gt; , Tag , V &gt; (<span class="self">self </span>, other : &amp; N2 ,) -&gt; Stream &lt; <span class="lifetime">'a </span>, T , Async , N2 &gt; <span class="kw">where </span>N : HfSend &lt; <span class="lifetime">'a </span>, N2 , V , In &lt; T &gt; = (N2 :: Id , T) , Out &lt; T &gt; = (Tag , T) &gt; , T : Serialize + DeserializeOwned , N2 :: Id : Clone , { <span class="self">self </span>. broadcast_bincode (other) . map (q ! (| (<span class="kw">_ </span>, b) | b)) } <span class="kw">pub fn </span>broadcast_bytes &lt; N2 : Location &lt; <span class="lifetime">'a </span>&gt; + Cluster &lt; <span class="lifetime">'a </span>&gt; , V &gt; (<span class="self">self </span>, other : &amp; N2 ,) -&gt; Stream &lt; <span class="lifetime">'a </span>, N :: Out &lt; Bytes &gt; , Async , N2 &gt; <span class="kw">where </span>N : HfSend &lt; <span class="lifetime">'a </span>, N2 , V , In &lt; Bytes &gt; = (N2 :: Id , T) &gt; , N2 :: Id : Clone , { <span class="kw">let </span>other_ids = <span class="self">self </span>. node . source_iter (other . ids ()) . cloned () . all_ticks () ; other_ids . cross_product (<span class="self">self </span>. assume_windowed ()) . send_bytes (other) } <span class="kw">pub fn </span>broadcast_bytes_interleaved &lt; N2 : Location &lt; <span class="lifetime">'a </span>&gt; + Cluster &lt; <span class="lifetime">'a </span>&gt; , Tag , V &gt; (<span class="self">self </span>, other : &amp; N2 ,) -&gt; Stream &lt; <span class="lifetime">'a </span>, Bytes , Async , N2 &gt; <span class="kw">where </span>N : HfSend &lt; <span class="lifetime">'a </span>, N2 , V , In &lt; Bytes &gt; = (N2 :: Id , T) , Out &lt; Bytes &gt; = (Tag , Bytes) &gt; , N2 :: Id : Clone , { <span class="self">self </span>. broadcast_bytes (other) . map (q ! (| (<span class="kw">_ </span>, b) | b)) } } } <span class="kw">pub use </span>stream :: Stream ; <span class="kw">pub mod </span>location { <span class="kw">pub use </span>std :: cell :: RefCell ; <span class="kw">pub use </span>std :: marker :: PhantomData ; <span class="kw">pub use </span>std :: time :: Duration ; <span class="kw">pub use </span>hydroflow :: bytes :: Bytes ; <span class="kw">pub use </span>hydroflow :: futures :: stream :: Stream <span class="kw">as </span>FuturesStream ; <span class="kw">pub use </span>proc_macro2 :: Span ; <span class="kw">pub use </span>stageleft :: { q , Quoted } ; <span class="kw">pub use </span>syn :: parse_quote ; <span class="kw">pub use crate </span>:: ir :: { HfPlusLeaf , HfPlusNode , HfPlusSource } ; <span class="kw">pub use crate </span>:: stream :: { Async , Windowed } ; <span class="kw">pub use crate </span>:: { FlowBuilder , HfCycle , Stream } ; <span class="kw">pub mod </span>graphs { <span class="kw">pub use </span>std :: cell :: RefCell ; <span class="kw">pub use </span>std :: rc :: Rc ; <span class="kw">pub use </span>stageleft :: { Quoted , RuntimeData } ; <span class="kw">pub use super </span>:: { Cluster , LocalDeploy , Location , ProcessSpec } ; <span class="kw">pub use crate </span>:: ir :: HfPlusLeaf ; <span class="kw">pub use crate </span>:: FlowBuilder ; <span class="kw">pub use crate </span>:: location :: graphs :: SingleProcessGraph ; # [cfg (feature = <span class="string">"macro"</span>)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; LocalDeploy &lt; <span class="lifetime">'a </span>&gt; <span class="kw">for </span>SingleProcessGraph { <span class="kw">type </span>ClusterId = () ; <span class="kw">type </span>Process = SingleNode &lt; <span class="lifetime">'a </span>&gt; ; <span class="kw">type </span>Cluster = SingleNode &lt; <span class="lifetime">'a </span>&gt; ; <span class="kw">type </span>Meta = () ; <span class="kw">type </span>GraphId = () ; } # [cfg (feature = <span class="string">"macro"</span>)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; ProcessSpec &lt; <span class="lifetime">'a </span>, SingleProcessGraph &gt; <span class="kw">for </span>() { <span class="kw">fn </span>build (&amp; <span class="self">self </span>, _id : usize , builder : &amp; <span class="lifetime">'a </span>FlowBuilder &lt; <span class="lifetime">'a </span>, SingleProcessGraph &gt; , _meta : &amp; <span class="kw-2">mut </span>() ,) -&gt; SingleNode &lt; <span class="lifetime">'a </span>&gt; { SingleNode { builder , cycle_counter : Rc :: new (RefCell :: new (<span class="number">0</span>)) , } } } <span class="kw">pub use crate </span>:: location :: graphs :: SingleNode ; # [cfg (feature = <span class="string">"macro"</span>)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; Location &lt; <span class="lifetime">'a </span>&gt; <span class="kw">for </span>SingleNode &lt; <span class="lifetime">'a </span>&gt; { <span class="kw">type </span>Port = () ; <span class="kw">type </span>Meta = () ; <span class="kw">fn </span>id (&amp; <span class="self">self</span>) -&gt; usize { <span class="number">0 </span>} <span class="kw">fn </span>ir_leaves (&amp; <span class="self">self</span>) -&gt; &amp; <span class="lifetime">'a </span>RefCell &lt; Vec &lt; HfPlusLeaf &gt; &gt; { <span class="self">self </span>. builder . ir_leaves () } <span class="kw">fn </span>cycle_counter (&amp; <span class="self">self</span>) -&gt; &amp; RefCell &lt; usize &gt; { <span class="self">self </span>. cycle_counter . as_ref () } <span class="kw">fn </span>next_port (&amp; <span class="self">self</span>) { panic ! () ; } <span class="kw">fn </span>update_meta (&amp; <span class="kw-2">mut </span><span class="self">self </span>, _meta : &amp; <span class="self">Self </span>:: Meta) { } } # [cfg (feature = <span class="string">"macro"</span>)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; Cluster &lt; <span class="lifetime">'a </span>&gt; <span class="kw">for </span>SingleNode &lt; <span class="lifetime">'a </span>&gt; { <span class="kw">type </span>Id = () ; <span class="kw">fn </span>ids (&amp; <span class="self">self</span>) -&gt; <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, &amp; <span class="lifetime">'a </span>Vec &lt; () &gt; &gt; + Copy + <span class="lifetime">'a </span>{ panic ! () ; # [allow (unreachable_code)] RuntimeData :: new (<span class="string">""</span>) } } <span class="kw">pub use crate </span>:: location :: graphs :: MultiGraph ; # [cfg (feature = <span class="string">"macro"</span>)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; LocalDeploy &lt; <span class="lifetime">'a </span>&gt; <span class="kw">for </span>MultiGraph { <span class="kw">type </span>ClusterId = u32 ; <span class="kw">type </span>Process = MultiNode &lt; <span class="lifetime">'a </span>&gt; ; <span class="kw">type </span>Cluster = MultiNode &lt; <span class="lifetime">'a </span>&gt; ; <span class="kw">type </span>Meta = () ; <span class="kw">type </span>GraphId = usize ; } # [cfg (feature = <span class="string">"macro"</span>)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; ProcessSpec &lt; <span class="lifetime">'a </span>, MultiGraph &gt; <span class="kw">for </span>() { <span class="kw">fn </span>build (&amp; <span class="self">self </span>, id : usize , builder : &amp; <span class="lifetime">'a </span>FlowBuilder &lt; <span class="lifetime">'a </span>, MultiGraph &gt; , _meta : &amp; <span class="kw-2">mut </span>() ,) -&gt; MultiNode &lt; <span class="lifetime">'a </span>&gt; { MultiNode { builder , id , cycle_counter : Rc :: new (RefCell :: new (<span class="number">0</span>)) , } } } <span class="kw">pub use crate </span>:: location :: graphs :: MultiNode ; # [cfg (feature = <span class="string">"macro"</span>)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; Location &lt; <span class="lifetime">'a </span>&gt; <span class="kw">for </span>MultiNode &lt; <span class="lifetime">'a </span>&gt; { <span class="kw">type </span>Port = () ; <span class="kw">type </span>Meta = () ; <span class="kw">fn </span>id (&amp; <span class="self">self</span>) -&gt; usize { <span class="self">self </span>. id } <span class="kw">fn </span>ir_leaves (&amp; <span class="self">self</span>) -&gt; &amp; <span class="lifetime">'a </span>RefCell &lt; Vec &lt; HfPlusLeaf &gt; &gt; { <span class="self">self </span>. builder . ir_leaves () } <span class="kw">fn </span>cycle_counter (&amp; <span class="self">self</span>) -&gt; &amp; RefCell &lt; usize &gt; { <span class="self">self </span>. cycle_counter . as_ref () } <span class="kw">fn </span>next_port (&amp; <span class="self">self</span>) { panic ! () ; } <span class="kw">fn </span>update_meta (&amp; <span class="kw-2">mut </span><span class="self">self </span>, _meta : &amp; <span class="self">Self </span>:: Meta) { } } # [cfg (feature = <span class="string">"macro"</span>)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; Cluster &lt; <span class="lifetime">'a </span>&gt; <span class="kw">for </span>MultiNode &lt; <span class="lifetime">'a </span>&gt; { <span class="kw">type </span>Id = u32 ; <span class="kw">fn </span>ids (&amp; <span class="self">self</span>) -&gt; <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, &amp; <span class="lifetime">'a </span>Vec &lt; u32 &gt; &gt; + Copy + <span class="lifetime">'a </span>{ panic ! () ; # [allow (unreachable_code)] RuntimeData :: new (<span class="string">""</span>) } } } <span class="kw">pub use </span>graphs :: * ; <span class="kw">pub mod </span>network { <span class="kw">pub use super </span>:: Location ; <span class="kw">pub use crate </span>:: location :: network :: HfSend ; <span class="kw">pub use crate </span>:: location :: network :: HfSendOneToOne ; # [cfg (feature = <span class="string">"macro"</span>)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, O : Location &lt; <span class="lifetime">'a </span>&gt; , H : HfSendOneToOne &lt; <span class="lifetime">'a </span>, O &gt; &gt; HfSend &lt; <span class="lifetime">'a </span>, O , () &gt; <span class="kw">for </span>H { <span class="kw">type </span>In &lt; T &gt; = T ; <span class="kw">type </span>Out &lt; T &gt; = T ; <span class="kw">fn </span>connect (&amp; <span class="self">self </span>, other : &amp; O , source_port : &amp; <span class="self">Self </span>:: Port , recipient_port : &amp; O :: Port) { H :: connect (<span class="self">self </span>, other , source_port , recipient_port) ; } <span class="kw">fn </span>gen_sink_statement (&amp; <span class="self">self </span>, port : &amp; <span class="self">Self </span>:: Port) -&gt; syn :: Expr { H :: gen_sink_statement (<span class="self">self </span>, port) } <span class="kw">fn </span>gen_source_statement (other : &amp; O , port : &amp; O :: Port) -&gt; syn :: Expr { H :: gen_source_statement (other , port) } <span class="kw">fn </span>is_demux () -&gt; bool { <span class="bool-val">false </span>} <span class="kw">fn </span>is_tagged () -&gt; bool { <span class="bool-val">false </span>} } <span class="kw">pub use crate </span>:: location :: network :: HfSendManyToOne ; # [cfg (feature = <span class="string">"macro"</span>)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, O : Location &lt; <span class="lifetime">'a </span>&gt; , Tag , H : HfSendManyToOne &lt; <span class="lifetime">'a </span>, O , Tag &gt; &gt; HfSend &lt; <span class="lifetime">'a </span>, O , (() , Tag) &gt; <span class="kw">for </span>H { <span class="kw">type </span>In &lt; T &gt; = T ; <span class="kw">type </span>Out &lt; T &gt; = (Tag , T) ; <span class="kw">fn </span>connect (&amp; <span class="self">self </span>, other : &amp; O , source_port : &amp; <span class="self">Self </span>:: Port , recipient_port : &amp; O :: Port) { H :: connect (<span class="self">self </span>, other , source_port , recipient_port) ; } <span class="kw">fn </span>gen_sink_statement (&amp; <span class="self">self </span>, port : &amp; <span class="self">Self </span>:: Port) -&gt; syn :: Expr { H :: gen_sink_statement (<span class="self">self </span>, port) } <span class="kw">fn </span>gen_source_statement (other : &amp; O , port : &amp; O :: Port) -&gt; syn :: Expr { H :: gen_source_statement (other , port) } <span class="kw">fn </span>is_demux () -&gt; bool { <span class="bool-val">false </span>} <span class="kw">fn </span>is_tagged () -&gt; bool { <span class="bool-val">true </span>} } <span class="kw">pub use crate </span>:: location :: network :: HfSendOneToMany ; # [cfg (feature = <span class="string">"macro"</span>)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, O : Location &lt; <span class="lifetime">'a </span>&gt; , Cid , H : HfSendOneToMany &lt; <span class="lifetime">'a </span>, O , Cid &gt; &gt; HfSend &lt; <span class="lifetime">'a </span>, O , (() , () , Cid) &gt; <span class="kw">for </span>H { <span class="kw">type </span>In &lt; T &gt; = (Cid , T) ; <span class="kw">type </span>Out &lt; T &gt; = T ; <span class="kw">fn </span>connect (&amp; <span class="self">self </span>, other : &amp; O , source_port : &amp; <span class="self">Self </span>:: Port , recipient_port : &amp; O :: Port) { H :: connect (<span class="self">self </span>, other , source_port , recipient_port) ; } <span class="kw">fn </span>gen_sink_statement (&amp; <span class="self">self </span>, port : &amp; <span class="self">Self </span>:: Port) -&gt; syn :: Expr { H :: gen_sink_statement (<span class="self">self </span>, port) } <span class="kw">fn </span>gen_source_statement (other : &amp; O , port : &amp; O :: Port) -&gt; syn :: Expr { H :: gen_source_statement (other , port) } <span class="kw">fn </span>is_demux () -&gt; bool { <span class="bool-val">true </span>} <span class="kw">fn </span>is_tagged () -&gt; bool { <span class="bool-val">false </span>} } <span class="kw">pub use crate </span>:: location :: network :: HfSendManyToMany ; # [cfg (feature = <span class="string">"macro"</span>)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, O : Location &lt; <span class="lifetime">'a </span>&gt; , Cid , H : HfSendManyToMany &lt; <span class="lifetime">'a </span>, O , Cid &gt; &gt; HfSend &lt; <span class="lifetime">'a </span>, O , (() , () , Cid , Cid) &gt; <span class="kw">for </span>H { <span class="kw">type </span>In &lt; T &gt; = (Cid , T) ; <span class="kw">type </span>Out &lt; T &gt; = (Cid , T) ; <span class="kw">fn </span>connect (&amp; <span class="self">self </span>, other : &amp; O , source_port : &amp; <span class="self">Self </span>:: Port , recipient_port : &amp; O :: Port) { H :: connect (<span class="self">self </span>, other , source_port , recipient_port) ; } <span class="kw">fn </span>gen_sink_statement (&amp; <span class="self">self </span>, port : &amp; <span class="self">Self </span>:: Port) -&gt; syn :: Expr { H :: gen_sink_statement (<span class="self">self </span>, port) } <span class="kw">fn </span>gen_source_statement (other : &amp; O , port : &amp; O :: Port) -&gt; syn :: Expr { H :: gen_source_statement (other , port) } <span class="kw">fn </span>is_demux () -&gt; bool { <span class="bool-val">true </span>} <span class="kw">fn </span>is_tagged () -&gt; bool { <span class="bool-val">true </span>} } } <span class="kw">pub use </span>network :: * ; <span class="kw">pub use crate </span>:: location :: LocalDeploy ; <span class="kw">pub use crate </span>:: location :: Deploy ; # [cfg (feature = <span class="string">"macro"</span>)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, Cid : Clone + <span class="lifetime">'static </span>, T : Deploy &lt; <span class="lifetime">'a </span>, ClusterId = Cid , Process = N , Cluster = C , Meta = M , GraphId = R &gt; , N : Location &lt; <span class="lifetime">'a </span>, Meta = M &gt; + HfSendOneToOne &lt; <span class="lifetime">'a </span>, N &gt; + HfSendOneToMany &lt; <span class="lifetime">'a </span>, C , Cid &gt; , C : Location &lt; <span class="lifetime">'a </span>, Meta = M &gt; + HfSendManyToOne &lt; <span class="lifetime">'a </span>, N , Cid &gt; + HfSendManyToMany &lt; <span class="lifetime">'a </span>, C , Cid &gt; + Cluster &lt; <span class="lifetime">'a </span>, Id = Cid &gt; , M : Default , R , &gt; LocalDeploy &lt; <span class="lifetime">'a </span>&gt; <span class="kw">for </span>T { <span class="kw">type </span>ClusterId = Cid ; <span class="kw">type </span>Process = N ; <span class="kw">type </span>Cluster = C ; <span class="kw">type </span>Meta = M ; <span class="kw">type </span>GraphId = R ; } <span class="kw">pub use crate </span>:: location :: ProcessSpec ; <span class="kw">pub use crate </span>:: location :: ClusterSpec ; <span class="kw">pub use crate </span>:: location :: Location ; <span class="kw">pub use crate </span>:: location :: Cluster ; } <span class="kw">pub use </span>location :: { Cluster , ClusterSpec , Deploy , LocalDeploy , Location , MultiGraph , ProcessSpec , SingleProcessGraph , } ; <span class="kw">pub mod </span>cycle { <span class="kw">pub use </span>std :: cell :: RefCell ; <span class="kw">pub use </span>std :: marker :: PhantomData ; <span class="kw">pub use crate </span>:: ir :: HfPlusLeaf ; <span class="kw">pub use crate </span>:: location :: Location ; <span class="kw">pub use crate </span>:: Stream ; <span class="kw">pub use crate </span>:: cycle :: HfCycle ; # [cfg (feature = <span class="string">"macro"</span>)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , W , N : Location &lt; <span class="lifetime">'a </span>&gt; &gt; HfCycle &lt; <span class="lifetime">'a </span>, T , W , N &gt; { <span class="kw">pub fn </span>complete (<span class="self">self </span>, stream : Stream &lt; <span class="lifetime">'a </span>, T , W , N &gt;) { <span class="kw">let </span>ident = <span class="self">self </span>. ident ; <span class="self">self </span>. ir_leaves . borrow_mut () . push (HfPlusLeaf :: CycleSink { ident , location_id : <span class="self">self </span>. node . id () , input : Box :: new (stream . ir_node . into_inner ()) , }) ; } } } <span class="kw">pub use </span>cycle :: HfCycle ; <span class="kw">pub mod </span>builder { <span class="kw">pub use </span>std :: cell :: { Ref , RefCell } ; <span class="kw">pub use </span>std :: collections :: { BTreeMap , HashMap } ; <span class="kw">pub use </span>std :: marker :: PhantomData ; <span class="kw">pub use </span>hydroflow_lang :: graph :: { eliminate_extra_unions_tees , partition_graph , propagate_flow_props , HydroflowGraph , } ; <span class="kw">pub use </span>proc_macro2 :: { Span , TokenStream } ; <span class="kw">pub use </span>quote :: quote ; <span class="kw">pub use </span>stageleft :: { Quoted , QuotedContext } ; <span class="kw">pub use </span>syn :: parse_quote ; <span class="kw">pub use crate </span>:: ir :: HfPlusLeaf ; <span class="kw">pub use crate </span>:: location :: { ClusterSpec , LocalDeploy , Location , ProcessSpec } ; <span class="kw">pub use crate </span>:: { HfBuilt , RuntimeContext } ; <span class="kw">pub use crate </span>:: builder :: FlowBuilder ; # [cfg (feature = <span class="string">"macro"</span>)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, D : LocalDeploy &lt; <span class="lifetime">'a </span>&gt; + <span class="question-mark">? </span>Sized &gt; FlowBuilder &lt; <span class="lifetime">'a </span>, D &gt; { <span class="kw">pub fn </span>ir (&amp; <span class="self">self</span>) -&gt; Ref &lt; <span class="lifetime">'_ </span>, Vec &lt; HfPlusLeaf &gt; &gt; { <span class="self">self </span>. ir_leaves . borrow () } } # [cfg (feature = <span class="string">"macro"</span>)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, D : LocalDeploy &lt; <span class="lifetime">'a </span>&gt; &gt; QuotedContext <span class="kw">for </span>FlowBuilder &lt; <span class="lifetime">'a </span>, D &gt; { <span class="kw">fn </span>create () -&gt; <span class="self">Self </span>{ FlowBuilder :: new () } } # [cfg (feature = <span class="string">"macro"</span>)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, D : LocalDeploy &lt; <span class="lifetime">'a </span>&gt; &gt; FlowBuilder &lt; <span class="lifetime">'a </span>, D &gt; { # [allow (clippy :: new_without_default)] <span class="kw">pub fn </span>new () -&gt; FlowBuilder &lt; <span class="lifetime">'a </span>, D &gt; { FlowBuilder { ir_leaves : RefCell :: new (Vec :: new ()) , nodes : RefCell :: new (Vec :: new ()) , clusters : RefCell :: new (Vec :: new ()) , meta : RefCell :: new (Default :: default ()) , next_node_id : RefCell :: new (<span class="number">0</span>) , _phantom : PhantomData , } } <span class="kw">pub fn </span>ir_leaves (&amp; <span class="self">self</span>) -&gt; &amp; RefCell &lt; Vec &lt; HfPlusLeaf &gt; &gt; { &amp; <span class="self">self </span>. ir_leaves } <span class="kw">pub fn </span>process (&amp; <span class="lifetime">'a </span><span class="self">self </span>, spec : &amp; <span class="kw">impl </span>ProcessSpec &lt; <span class="lifetime">'a </span>, D &gt;) -&gt; D :: Process { <span class="kw">let </span><span class="kw-2">mut </span>next_node_id = <span class="self">self </span>. next_node_id . borrow_mut () ; <span class="kw">let </span>id = * next_node_id ; * next_node_id += <span class="number">1 </span>; <span class="kw">let </span>node = spec . build (id , <span class="self">self </span>, &amp; <span class="kw-2">mut </span><span class="self">self </span>. meta . borrow_mut ()) ; <span class="self">self </span>. nodes . borrow_mut () . push (node . clone ()) ; <span class="self">self </span>. update_metas () ; node } <span class="kw">pub fn </span>cluster (&amp; <span class="lifetime">'a </span><span class="self">self </span>, spec : &amp; <span class="kw">impl </span>ClusterSpec &lt; <span class="lifetime">'a </span>, D &gt;) -&gt; D :: Cluster { <span class="kw">let </span><span class="kw-2">mut </span>next_node_id = <span class="self">self </span>. next_node_id . borrow_mut () ; <span class="kw">let </span>id = * next_node_id ; * next_node_id += <span class="number">1 </span>; <span class="kw">let </span>cluster = spec . build (id , <span class="self">self </span>, &amp; <span class="kw-2">mut </span><span class="self">self </span>. meta . borrow_mut ()) ; <span class="self">self </span>. clusters . borrow_mut () . push (cluster . clone ()) ; <span class="self">self </span>. update_metas () ; cluster } <span class="kw">pub fn </span>runtime_context (&amp; <span class="self">self</span>) -&gt; RuntimeContext &lt; <span class="lifetime">'a </span>&gt; { RuntimeContext { _phantom : PhantomData , } } <span class="kw">fn </span>update_metas (&amp; <span class="self">self</span>) { <span class="self">self </span>. nodes . borrow_mut () . iter_mut () . for_each (| n | n . update_meta (&amp; <span class="self">self </span>. meta . borrow ())) ; <span class="self">self </span>. clusters . borrow_mut () . iter_mut () . for_each (| n | n . update_meta (&amp; <span class="self">self </span>. meta . borrow ())) ; } } <span class="kw">pub fn </span>build_inner &lt; <span class="lifetime">'a </span>, D : LocalDeploy &lt; <span class="lifetime">'a </span>&gt; &gt; (me : &amp; FlowBuilder &lt; <span class="lifetime">'a </span>, D &gt; , id : syn :: Expr , is_single : bool ,) -&gt; HfBuilt &lt; <span class="lifetime">'a </span>&gt; { <span class="kw">let </span><span class="kw-2">mut </span>builders = BTreeMap :: new () ; <span class="kw">let </span><span class="kw-2">mut </span>built_tees = HashMap :: new () ; <span class="kw">let </span><span class="kw-2">mut </span>next_stmt_id = <span class="number">0 </span>; <span class="kw">for </span>leaf <span class="kw">in </span>me . ir_leaves () . replace (Default :: default ()) { leaf . emit (&amp; <span class="kw-2">mut </span>builders , &amp; <span class="kw-2">mut </span>built_tees , &amp; <span class="kw-2">mut </span>next_stmt_id) ; } <span class="kw">if </span>is_single &amp;&amp; builders . len () != <span class="number">1 </span>{ panic ! (<span class="string">"Expected exactly one node in the graph."</span>) ; } <span class="kw">let </span><span class="kw-2">mut </span>conditioned_tokens = <span class="prelude-val">None </span>; <span class="kw">for </span>(subgraph_id , builder) <span class="kw">in </span>builders { <span class="kw">let </span>(<span class="kw-2">mut </span>flat_graph , <span class="kw">_ </span>, <span class="kw">_</span>) = builder . build () ; eliminate_extra_unions_tees (&amp; <span class="kw-2">mut </span>flat_graph) ; <span class="kw">let </span><span class="kw-2">mut </span>partitioned_graph = partition_graph (flat_graph) . expect (<span class="string">"Failed to partition (cycle detected)."</span>) ; <span class="kw">let </span>hydroflow_crate = proc_macro_crate :: crate_name (<span class="string">"hydroflow_plus"</span>) . expect (<span class="string">"hydroflow_plus should be present in `Cargo.toml`"</span>) ; <span class="kw">let </span>root = <span class="kw">match </span>hydroflow_crate { proc_macro_crate :: FoundCrate :: Itself =&gt; quote ! { hydroflow_plus } , proc_macro_crate :: FoundCrate :: Name (name) =&gt; { <span class="kw">let </span>ident = syn :: Ident :: new (&amp; name , Span :: call_site ()) ; quote ! { # ident } } } ; <span class="kw">let </span><span class="kw-2">mut </span>diagnostics = Vec :: new () ; <span class="kw">let _ </span>= propagate_flow_props :: propagate_flow_props (&amp; <span class="kw-2">mut </span>partitioned_graph , &amp; <span class="kw-2">mut </span>diagnostics) ; <span class="kw">let </span>tokens = partitioned_graph . as_code (&amp; root , <span class="bool-val">true </span>, quote :: quote ! () , &amp; <span class="kw-2">mut </span>diagnostics) ; <span class="kw">if let </span><span class="prelude-val">Some </span>(conditioned_tokens) = conditioned_tokens . as_mut () { * conditioned_tokens = parse_quote ! { # conditioned_tokens <span class="kw">else if </span>__given_id == # subgraph_id { # tokens } } ; } <span class="kw">else </span>{ conditioned_tokens = <span class="prelude-val">Some </span>(parse_quote ! { <span class="kw">if </span>__given_id == # subgraph_id { # tokens } }) ; } } <span class="kw">let </span>conditioned_tokens : TokenStream = conditioned_tokens . unwrap () ; HfBuilt { tokens : parse_quote ! ({ <span class="kw">let </span>__given_id = # id ; # conditioned_tokens <span class="kw">else </span>{ panic ! (<span class="string">"Invalid node id: {}" </span>, __given_id) ; } }) , _phantom : PhantomData , } } # [cfg (feature = <span class="string">"macro"</span>)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, D : LocalDeploy &lt; <span class="lifetime">'a </span>, GraphId = usize &gt; &gt; FlowBuilder &lt; <span class="lifetime">'a </span>, D &gt; { <span class="kw">pub fn </span>build (&amp; <span class="self">self </span>, id : <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, usize &gt;) -&gt; HfBuilt &lt; <span class="lifetime">'a </span>&gt; { build_inner (<span class="self">self </span>, id . splice () , <span class="bool-val">false</span>) } <span class="kw">pub fn </span>hydroflow_ir (&amp; <span class="self">self</span>) -&gt; BTreeMap &lt; usize , HydroflowGraph &gt; { <span class="kw">let </span><span class="kw-2">mut </span>builders = BTreeMap :: new () ; <span class="kw">let </span><span class="kw-2">mut </span>built_tees = HashMap :: new () ; <span class="kw">let </span><span class="kw-2">mut </span>next_stmt_id = <span class="number">0 </span>; <span class="kw">let </span>borrowed_leaves = <span class="self">self </span>. ir_leaves . borrow () ; <span class="kw">for </span>leaf <span class="kw">in </span>borrowed_leaves . iter () { leaf . clone () . emit (&amp; <span class="kw-2">mut </span>builders , &amp; <span class="kw-2">mut </span>built_tees , &amp; <span class="kw-2">mut </span>next_stmt_id) ; } <span class="kw">let </span><span class="kw-2">mut </span>result = BTreeMap :: new () ; <span class="kw">for </span>(subgraph_id , builder) <span class="kw">in </span>builders { <span class="kw">let </span>(flat_graph , <span class="kw">_ </span>, <span class="kw">_</span>) = builder . build () ; result . insert (subgraph_id , flat_graph) ; } result } } # [cfg (feature = <span class="string">"macro"</span>)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, D : LocalDeploy &lt; <span class="lifetime">'a </span>, GraphId = () &gt; &gt; FlowBuilder &lt; <span class="lifetime">'a </span>, D &gt; { <span class="kw">pub fn </span>build_single (&amp; <span class="self">self</span>) -&gt; HfBuilt &lt; <span class="lifetime">'a </span>&gt; { build_inner (<span class="self">self </span>, parse_quote ! (<span class="number">0</span>) , <span class="bool-val">true</span>) } <span class="kw">pub fn </span>single_hydroflow_ir (&amp; <span class="self">self</span>) -&gt; HydroflowGraph { <span class="kw">let </span><span class="kw-2">mut </span>builders = BTreeMap :: new () ; <span class="kw">let </span><span class="kw-2">mut </span>built_tees = HashMap :: new () ; <span class="kw">let </span><span class="kw-2">mut </span>next_stmt_id = <span class="number">0 </span>; <span class="kw">let </span>borrowed_leaves = <span class="self">self </span>. ir_leaves . borrow () ; <span class="kw">for </span>leaf <span class="kw">in </span>borrowed_leaves . iter () { leaf . clone () . emit (&amp; <span class="kw-2">mut </span>builders , &amp; <span class="kw-2">mut </span>built_tees , &amp; <span class="kw-2">mut </span>next_stmt_id) ; } <span class="kw">if </span>builders . len () != <span class="number">1 </span>{ panic ! (<span class="string">"Expected exactly one node in the graph."</span>) ; } builders . remove (&amp; <span class="number">0</span>) . expect (<span class="string">"expected a single graph"</span>) . build () . <span class="number">0 </span>} } } <span class="kw">pub use </span>builder :: FlowBuilder ; <span class="kw">pub mod </span>ir { <span class="kw">pub use </span>std :: cell :: RefCell ; <span class="kw">pub use </span>std :: collections :: { BTreeMap , HashMap } ; <span class="kw">pub use </span>std :: ops :: Deref ; <span class="kw">pub use </span>std :: rc :: Rc ; <span class="kw">pub use </span>hydroflow_lang :: graph :: FlatGraphBuilder ; <span class="kw">pub use </span>hydroflow_lang :: parse :: Pipeline ; <span class="kw">pub use </span>proc_macro2 :: { Span , TokenStream } ; <span class="kw">pub use </span>quote :: ToTokens ; <span class="kw">pub use </span>syn :: parse_quote ; <span class="kw">pub use crate </span>:: ir :: DebugExpr ; # [cfg (feature = <span class="string">"macro"</span>)] <span class="kw">impl </span>From &lt; syn :: Expr &gt; <span class="kw">for </span>DebugExpr { <span class="kw">fn </span>from (expr : syn :: Expr) -&gt; DebugExpr { DebugExpr (expr) } } # [cfg (feature = <span class="string">"macro"</span>)] <span class="kw">impl </span>Deref <span class="kw">for </span>DebugExpr { <span class="kw">type </span>Target = syn :: Expr ; <span class="kw">fn </span>deref (&amp; <span class="self">self</span>) -&gt; &amp; <span class="self">Self </span>:: Target { &amp; <span class="self">self </span>. <span class="number">0 </span>} } # [cfg (feature = <span class="string">"macro"</span>)] <span class="kw">impl </span>ToTokens <span class="kw">for </span>DebugExpr { <span class="kw">fn </span>to_tokens (&amp; <span class="self">self </span>, tokens : &amp; <span class="kw-2">mut </span>TokenStream) { <span class="self">self </span>. <span class="number">0 </span>. to_tokens (tokens) ; } } # [cfg (feature = <span class="string">"macro"</span>)] <span class="kw">impl </span>std :: fmt :: Debug <span class="kw">for </span>DebugExpr { <span class="kw">fn </span>fmt (&amp; <span class="self">self </span>, f : &amp; <span class="kw-2">mut </span>std :: fmt :: Formatter &lt; <span class="lifetime">'_ </span>&gt;) -&gt; std :: fmt :: <span class="prelude-ty">Result </span>{ write ! (f , <span class="string">"{}" </span>, <span class="self">self </span>. <span class="number">0 </span>. to_token_stream ()) } } <span class="kw">pub use crate </span>:: ir :: DebugPipelineFn ; # [cfg (feature = <span class="string">"macro"</span>)] <span class="kw">impl </span>std :: fmt :: Debug <span class="kw">for </span>DebugPipelineFn { <span class="kw">fn </span>fmt (&amp; <span class="self">self </span>, f : &amp; <span class="kw-2">mut </span>std :: fmt :: Formatter &lt; <span class="lifetime">'_ </span>&gt;) -&gt; std :: fmt :: <span class="prelude-ty">Result </span>{ write ! (f , <span class="string">"&lt;function&gt;"</span>) } } <span class="kw">pub use crate </span>:: ir :: HfPlusSource ; <span class="kw">pub use crate </span>:: ir :: HfPlusLeaf ; # [cfg (feature = <span class="string">"macro"</span>)] <span class="kw">impl </span>HfPlusLeaf { <span class="kw">pub fn </span>emit (<span class="self">self </span>, graph_builders : &amp; <span class="kw-2">mut </span>BTreeMap &lt; usize , FlatGraphBuilder &gt; , built_tees : &amp; <span class="kw-2">mut </span>HashMap &lt; * <span class="kw">const </span>RefCell &lt; HfPlusNode &gt; , (syn :: Ident , usize , bool) &gt; , next_stmt_id : &amp; <span class="kw-2">mut </span>usize ,) { <span class="kw">match </span><span class="self">self </span>{ HfPlusLeaf :: ForEach { f , input } =&gt; { <span class="kw">let </span>(input_ident , input_location_id , input_delta) = input . emit (graph_builders , built_tees , next_stmt_id) ; assert ! (! input_delta , <span class="string">"for_each on a delta stream"</span>) ; graph_builders . entry (input_location_id) . or_default () . add_statement (parse_quote ! { # input_ident -&gt; for_each (# f) ; }) ; } HfPlusLeaf :: DestSink { sink , input } =&gt; { <span class="kw">let </span>(input_ident , input_location_id , input_delta) = input . emit (graph_builders , built_tees , next_stmt_id) ; assert ! (! input_delta , <span class="string">"sending delta in dest_sink"</span>) ; graph_builders . entry (input_location_id) . or_default () . add_statement (parse_quote ! { # input_ident -&gt; dest_sink (# sink) ; }) ; } HfPlusLeaf :: CycleSink { ident , location_id , input , } =&gt; { <span class="kw">let </span>(input_ident , input_location_id , input_delta) = input . emit (graph_builders , built_tees , next_stmt_id) ; assert ! (! input_delta , <span class="string">"sending deltas into a cycle"</span>) ; assert_eq ! (input_location_id , location_id , <span class="string">"cycle_sink location mismatch"</span>) ; graph_builders . entry (location_id) . or_default () . add_statement (parse_quote ! { # ident = # input_ident ; }) ; } } } } <span class="kw">pub use crate </span>:: ir :: HfPlusNode ; # [cfg (feature = <span class="string">"macro"</span>)] <span class="kw">impl </span>HfPlusNode { <span class="kw">pub fn </span>emit (<span class="self">self </span>, graph_builders : &amp; <span class="kw-2">mut </span>BTreeMap &lt; usize , FlatGraphBuilder &gt; , built_tees : &amp; <span class="kw-2">mut </span>HashMap &lt; * <span class="kw">const </span>RefCell &lt; HfPlusNode &gt; , (syn :: Ident , usize , bool) &gt; , next_stmt_id : &amp; <span class="kw-2">mut </span>usize ,) -&gt; (syn :: Ident , usize , bool) { <span class="kw">match </span><span class="self">self </span>{ HfPlusNode :: Placeholder =&gt; { panic ! () } HfPlusNode :: Persist (inner) =&gt; { <span class="kw">let </span>(ident , location , inner_delta) = inner . emit (graph_builders , built_tees , next_stmt_id) ; assert ! (! inner_delta , <span class="string">"double persist"</span>) ; (ident , location , <span class="bool-val">true</span>) } HfPlusNode :: Delta (inner) =&gt; { <span class="kw">let </span>(inner_ident , location , inner_delta) = inner . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">if </span>inner_delta { (inner_ident , location , <span class="bool-val">false</span>) } <span class="kw">else </span>{ <span class="kw">let </span>delta_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>delta_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, delta_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (location) . or_default () ; builder . add_statement (parse_quote ! { # delta_ident = # inner_ident -&gt; multiset_delta () ; }) ; (delta_ident , location , <span class="bool-val">false</span>) } } HfPlusNode :: Source { source , produces_delta , location_id , } =&gt; { <span class="kw">let </span>source_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>source_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, source_id) , Span :: call_site ()) ; <span class="kw">let </span>source_stmt = <span class="kw">match </span>source { HfPlusSource :: Stream (expr) =&gt; { parse_quote ! { # source_ident = source_stream (# expr) ; } } HfPlusSource :: Iter (expr) =&gt; { parse_quote ! { # source_ident = source_iter (# expr) ; } } HfPlusSource :: Interval (expr) =&gt; { parse_quote ! { # source_ident = source_interval (# expr) ; } } HfPlusSource :: Spin () =&gt; { parse_quote ! { # source_ident = spin () ; } } } ; graph_builders . entry (location_id) . or_default () . add_statement (source_stmt) ; (source_ident , location_id , produces_delta) } HfPlusNode :: CycleSource { ident , location_id } =&gt; (ident . clone () , location_id , <span class="bool-val">false</span>) , HfPlusNode :: Tee { inner } =&gt; { <span class="kw">if let </span><span class="prelude-val">Some </span>(ret) = built_tees . get (&amp; (inner . as_ref () <span class="kw">as </span>* <span class="kw">const </span>RefCell &lt; HfPlusNode &gt;)) { ret . clone () } <span class="kw">else </span>{ <span class="kw">let </span>(inner_ident , inner_location_id , inner_produces_delta) = inner . replace (HfPlusNode :: Placeholder) . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>tee_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>tee_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, tee_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (inner_location_id) . or_default () ; builder . add_statement (parse_quote ! { # tee_ident = # inner_ident -&gt; tee () ; }) ; built_tees . insert (inner . as_ref () <span class="kw">as </span>* <span class="kw">const </span>RefCell &lt; HfPlusNode &gt; , (tee_ident . clone () , inner_location_id , inner_produces_delta) ,) ; (tee_ident , inner_location_id , inner_produces_delta) } } HfPlusNode :: Union (left , right) =&gt; { <span class="kw">let </span>(left_ident , left_location_id , left_delta) = left . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>(right_ident , right_location_id , right_delta) = right . emit (graph_builders , built_tees , next_stmt_id) ; assert_eq ! (left_location_id , right_location_id , <span class="string">"union inputs must be in the same location"</span>) ; assert ! (! left_delta , <span class="string">"union on a delta stream"</span>) ; assert ! (! right_delta , <span class="string">"union on a delta stream"</span>) ; <span class="kw">let </span>union_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>union_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, union_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (left_location_id) . or_default () ; builder . add_statement (parse_quote ! { # union_ident = union () ; }) ; builder . add_statement (parse_quote ! { # left_ident -&gt; [<span class="number">0</span>] # union_ident ; }) ; builder . add_statement (parse_quote ! { # right_ident -&gt; [<span class="number">1</span>] # union_ident ; }) ; (union_ident , left_location_id , <span class="bool-val">false</span>) } HfPlusNode :: CrossProduct (..) | HfPlusNode :: Join (..) =&gt; { <span class="kw">let </span>operator : syn :: Ident = <span class="kw">if </span>matches ! (<span class="self">self </span>, HfPlusNode :: CrossProduct (..)) { parse_quote ! (cross_join) } <span class="kw">else </span>{ parse_quote ! (join) } ; <span class="kw">if let </span>HfPlusNode :: CrossProduct (left , right) | HfPlusNode :: Join (left , right) = <span class="self">self </span>{ <span class="kw">let </span>(left_ident , left_location_id , left_delta) = left . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>(right_ident , right_location_id , right_delta) = right . emit (graph_builders , built_tees , next_stmt_id) ; assert_eq ! (left_location_id , right_location_id , <span class="string">"join / cross product inputs must be in the same location"</span>) ; <span class="kw">let </span>stream_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>stream_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, stream_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (left_location_id) . or_default () ; <span class="kw">let </span>output_delta = <span class="kw">match </span>(left_delta , right_delta) { (<span class="bool-val">true </span>, <span class="bool-val">true</span>) =&gt; { builder . add_statement (parse_quote ! { # stream_ident = # operator ::&lt;<span class="lifetime">'static </span>, <span class="lifetime">'static </span>&gt; () ; }) ; <span class="bool-val">false </span>} (<span class="bool-val">true </span>, <span class="bool-val">false</span>) =&gt; { builder . add_statement (parse_quote ! { # stream_ident = # operator ::&lt;<span class="lifetime">'static </span>, <span class="lifetime">'tick </span>&gt; () ; }) ; <span class="bool-val">false </span>} (<span class="bool-val">false </span>, <span class="bool-val">true</span>) =&gt; { builder . add_statement (parse_quote ! { # stream_ident = # operator ::&lt;<span class="lifetime">'tick </span>, <span class="lifetime">'static </span>&gt; () ; }) ; <span class="bool-val">false </span>} (<span class="bool-val">false </span>, <span class="bool-val">false</span>) =&gt; { builder . add_statement (parse_quote ! { # stream_ident = # operator ::&lt;<span class="lifetime">'tick </span>, <span class="lifetime">'tick </span>&gt; () ; }) ; <span class="bool-val">false </span>} } ; builder . add_statement (parse_quote ! { # left_ident -&gt; [<span class="number">0</span>] # stream_ident ; }) ; builder . add_statement (parse_quote ! { # right_ident -&gt; [<span class="number">1</span>] # stream_ident ; }) ; (stream_ident , left_location_id , output_delta) } <span class="kw">else </span>{ unreachable ! () } } HfPlusNode :: Difference (..) | HfPlusNode :: AntiJoin (..) =&gt; { <span class="kw">let </span>operator : syn :: Ident = <span class="kw">if </span>matches ! (<span class="self">self </span>, HfPlusNode :: Difference (..)) { parse_quote ! (difference) } <span class="kw">else </span>{ parse_quote ! (anti_join) } ; <span class="kw">if let </span>HfPlusNode :: Difference (left , right) | HfPlusNode :: AntiJoin (left , right) = <span class="self">self </span>{ <span class="kw">let </span>(left_ident , left_location_id , left_delta) = left . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>(right_ident , right_location_id , right_delta) = right . emit (graph_builders , built_tees , next_stmt_id) ; assert_eq ! (left_location_id , right_location_id , <span class="string">"difference / anti join inputs must be in the same location"</span>) ; <span class="kw">let </span>stream_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>stream_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, stream_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (left_location_id) . or_default () ; <span class="kw">let </span>output_delta = <span class="kw">match </span>(left_delta , right_delta) { (<span class="bool-val">true </span>, <span class="bool-val">true</span>) =&gt; { builder . add_statement (parse_quote ! { # stream_ident = # operator ::&lt;<span class="lifetime">'tick </span>, <span class="lifetime">'static </span>&gt; () ; }) ; <span class="bool-val">false </span>} (<span class="bool-val">true </span>, <span class="bool-val">false</span>) =&gt; { builder . add_statement (parse_quote ! { # stream_ident = # operator ::&lt;<span class="lifetime">'tick </span>, <span class="lifetime">'tick </span>&gt; () ; }) ; <span class="bool-val">false </span>} (<span class="bool-val">false </span>, <span class="bool-val">true</span>) =&gt; { builder . add_statement (parse_quote ! { # stream_ident = # operator ::&lt;<span class="lifetime">'tick </span>, <span class="lifetime">'static </span>&gt; () ; }) ; <span class="bool-val">false </span>} (<span class="bool-val">false </span>, <span class="bool-val">false</span>) =&gt; { builder . add_statement (parse_quote ! { # stream_ident = # operator ::&lt;<span class="lifetime">'tick </span>, <span class="lifetime">'tick </span>&gt; () ; }) ; <span class="bool-val">false </span>} } ; <span class="kw">if </span>left_delta { builder . add_statement (parse_quote ! { # left_ident -&gt; persist () -&gt; [pos] # stream_ident ; }) ; } <span class="kw">else </span>{ builder . add_statement (parse_quote ! { # left_ident -&gt; [pos] # stream_ident ; }) ; } builder . add_statement (parse_quote ! { # right_ident -&gt; [neg] # stream_ident ; }) ; (stream_ident , left_location_id , output_delta) } <span class="kw">else </span>{ unreachable ! () } } HfPlusNode :: Map { f , input } =&gt; { <span class="kw">let </span>(input_ident , input_location_id , input_delta) = input . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>map_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>map_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, map_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (input_location_id) . or_default () ; builder . add_statement (parse_quote ! { # map_ident = map (# f) ; }) ; builder . add_statement (parse_quote ! { # input_ident -&gt; # map_ident ; }) ; (map_ident , input_location_id , input_delta) } HfPlusNode :: Network { to_location , serialize_pipeline , sink_expr , source_expr , deserialize_pipeline , input , } =&gt; { <span class="kw">let </span>(input_ident , input_location_id , input_delta) = input . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>sender_builder = graph_builders . entry (input_location_id) . or_default () ; <span class="kw">if let </span><span class="prelude-val">Some </span>(serialize_pipeline) = serialize_pipeline { sender_builder . add_statement (parse_quote ! { # input_ident -&gt; # serialize_pipeline -&gt; dest_sink (# sink_expr) ; }) ; } <span class="kw">else </span>{ sender_builder . add_statement (parse_quote ! { # input_ident -&gt; dest_sink (# sink_expr) ; }) ; } <span class="kw">let </span>receiver_builder = graph_builders . entry (to_location) . or_default () ; <span class="kw">let </span>receiver_stream_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>receiver_stream_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, receiver_stream_id) , Span :: call_site ()) ; <span class="kw">if let </span><span class="prelude-val">Some </span>(deserialize_pipeline) = deserialize_pipeline { receiver_builder . add_statement (parse_quote ! { # receiver_stream_ident = source_stream (# source_expr) -&gt; # deserialize_pipeline ; }) ; } <span class="kw">else </span>{ receiver_builder . add_statement (parse_quote ! { # receiver_stream_ident = source_stream (# source_expr) ; }) ; } (receiver_stream_ident , to_location , input_delta) } HfPlusNode :: PipelineOp { kind : <span class="kw">_ </span>, gen_pipeline , input , } =&gt; { <span class="kw">let </span>(input_ident , input_location_id , input_delta) = input . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>pipeline_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>pipeline_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, pipeline_id) , Span :: call_site ()) ; <span class="kw">if let </span><span class="prelude-val">Some </span>((pipeline , is_delta)) = gen_pipeline . <span class="number">0 </span>(input_delta) { graph_builders . entry (input_location_id) . or_default () . add_statement (parse_quote ! { # pipeline_ident = # input_ident -&gt; # pipeline ; }) ; (pipeline_ident , input_location_id , is_delta) } <span class="kw">else if </span>input_delta { <span class="kw">let </span>(pipeline , is_delta) = gen_pipeline . <span class="number">0 </span>(<span class="bool-val">false</span>) . expect (<span class="string">"pipeline op refused to generate on a non-delta stream"</span>) ; graph_builders . entry (input_location_id) . or_default () . add_statement (parse_quote ! { # pipeline_ident = # input_ident -&gt; persist () -&gt; # pipeline ; }) ; (pipeline_ident , input_location_id , is_delta) } <span class="kw">else </span>{ panic ! (<span class="string">"pipeline op refused to generate on a non-delta stream"</span>) ; } } } } } } <span class="kw">pub use crate </span>:: RuntimeContext ; # [cfg (feature = <span class="string">"macro"</span>)] <span class="kw">impl </span>Copy <span class="kw">for </span>RuntimeContext &lt; <span class="lifetime">'_ </span>&gt; { } # [cfg (feature = <span class="string">"macro"</span>)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; FreeVariable &lt; &amp; <span class="lifetime">'a </span>Context &gt; <span class="kw">for </span>RuntimeContext &lt; <span class="lifetime">'a </span>&gt; { <span class="kw">fn </span>to_tokens (<span class="self">self</span>) -&gt; (<span class="prelude-ty">Option </span>&lt; TokenStream &gt; , <span class="prelude-ty">Option </span>&lt; TokenStream &gt;) { (<span class="prelude-val">None </span>, <span class="prelude-val">Some </span>(quote ! (&amp; context))) } } <span class="kw">pub use crate </span>:: HfBuilt ; # [cfg (feature = <span class="string">"macro"</span>)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; Quoted &lt; <span class="lifetime">'a </span>, Hydroflow &lt; <span class="lifetime">'a </span>&gt; &gt; <span class="kw">for </span>HfBuilt &lt; <span class="lifetime">'a </span>&gt; { } # [cfg (feature = <span class="string">"macro"</span>)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; FreeVariable &lt; Hydroflow &lt; <span class="lifetime">'a </span>&gt; &gt; <span class="kw">for </span>HfBuilt &lt; <span class="lifetime">'a </span>&gt; { <span class="kw">fn </span>to_tokens (<span class="self">self</span>) -&gt; (<span class="prelude-ty">Option </span>&lt; TokenStream &gt; , <span class="prelude-ty">Option </span>&lt; TokenStream &gt;) { (<span class="prelude-val">None </span>, <span class="prelude-val">Some </span>(<span class="self">self </span>. tokens)) } }</code></pre></div></section></main></body></html>