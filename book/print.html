<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Hydroflow Book</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">User Guide</li><li class="chapter-item expanded "><a href="quickstart.html"><strong aria-hidden="true">1.</strong> Quickstart</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="setup.html"><strong aria-hidden="true">1.1.</strong> Setup</a></li><li class="chapter-item expanded "><a href="example_1_simplest.html"><strong aria-hidden="true">1.2.</strong> Simplest Example</a></li><li class="chapter-item expanded "><a href="example_2_simple.html"><strong aria-hidden="true">1.3.</strong> Simple Example</a></li><li class="chapter-item expanded "><a href="example_3_stream.html"><strong aria-hidden="true">1.4.</strong> A Example With Streaming Input</a></li><li class="chapter-item expanded "><a href="example_4_neighbors.html"><strong aria-hidden="true">1.5.</strong> Graph Neighbors</a></li><li class="chapter-item expanded "><a href="example_5_reachability.html"><strong aria-hidden="true">1.6.</strong> Graph Reachability</a></li><li class="chapter-item expanded "><a href="example_6_unreachability.html"><strong aria-hidden="true">1.7.</strong> Graph Un-Reachability</a></li><li class="chapter-item expanded "><a href="example_7_echo_server.html"><strong aria-hidden="true">1.8.</strong> Networked Services 1: EchoServer</a></li></ol></li><li class="chapter-item expanded "><a href="concepts.html"><strong aria-hidden="true">2.</strong> Concepts</a></li><li class="chapter-item expanded "><a href="surface_syntax.html"><strong aria-hidden="true">3.</strong> Syntax</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="surface_embedding.html"><strong aria-hidden="true">3.1.</strong> Rust Embedding</a></li><li class="chapter-item expanded "><a href="surface_flows.html"><strong aria-hidden="true">3.2.</strong> Flows</a></li><li class="chapter-item expanded "><a href="surface_data.html"><strong aria-hidden="true">3.3.</strong> Data Sources</a></li><li class="chapter-item expanded "><a href="surface_ops.gen.html"><strong aria-hidden="true">3.4.</strong> Operators</a></li></ol></li><li class="chapter-item expanded "><a href="architecture.html"><strong aria-hidden="true">4.</strong> Architecture</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="in-out_trees.html"><strong aria-hidden="true">4.1.</strong> Subgraph In-Out Trees</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Hydroflow Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><a href="https://github.com/hydro-project/hydroflow">Hydroflow</a> is a compiler for low-latency 
dataflow programs, written in Rust. Hydroflow is the runtime library for the 
<a href="https://hydro-project.github.io/">Hydro Project</a>, which is under development
as a complete compiler stack for distributed programming languages. </p>
<p>Hydroflow provides a DSL—a <em>surface syntax</em>—embedded in Rust, which compiles to high-efficiency machine code. The Hydroflow DSL is the lowest level of the Hydro stack and 
requires some knowledge of Rust to use. In time the Hydro Project 
will deliver friendlier, higher-level languages that compile down to Hydroflow.</p>
<h2 id="this-book"><a class="header" href="#this-book">This Book</a></h2>
<p>This book will teach you how to set up your environment to get started with Hydroflow, and how to program in the Hydroflow surface syntax.</p>
<p>Keep in mind that Hydroflow is under active development and is constantly
changing. However this book is tested in CI so should always be up-to-date
(though incomplete, for now).</p>
<p>If you have any questions, feel free to <a href="https://github.com/hydro-project/hydroflow/issues/new">create an issue on Github</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quickstart"><a class="header" href="#quickstart">Quickstart</a></h1>
<p>This section will get you up and running with Rust and Hydroflow without
worrying too much about the tricky details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup"><a class="header" href="#setup">Setup</a></h1>
<p>This section explains how to get Hydroflow running, either for development or
usage, even if you are not familiar with Rust development.</p>
<h2 id="installing-rust"><a class="header" href="#installing-rust">Installing Rust</a></h2>
<p>First you will need to install Rust. We recommend the conventional installation
method, <code>rustup</code>, which allows you to easily manage and update Rust versions.</p>
<p><a href="https://www.rust-lang.org/tools/install"><strong>Install Rust</strong></a></p>
<p>This will install <code>rustup</code> and the Rust package manager <code>cargo</code> (and the
internally-used <code>rustc</code> compiler). <code>cargo</code> is Rust's main development tool,
used for building, running, and testing Rust code.</p>
<p>The following <code>cargo</code> commands will come in handy:</p>
<ul>
<li><code>cargo check --all-targets</code> - Checks the workspace for any compile-time
errors.</li>
<li><code>cargo build --all-targets</code> - Builds all projects/tests/benchmarks/examples
in the workspace.</li>
<li><code>cargo clean</code> - Cleans the build cache, sometimes needed if the build is
acting up.</li>
<li><code>cargo test</code> - Runs tests in the workspace.</li>
<li><code>cargo run -p hydroflow --example &lt;example name&gt;</code> - Run an example program in
<code>hydroflow/examples</code>.</li>
</ul>
<p>To learn Rust see the official <a href="https://www.rust-lang.org/learn">Learn Rust page</a>.
Here are some good resources:</p>
<ul>
<li><a href="https://doc.rust-lang.org/book/"><em>The Rust Programming Language</em>, AKA &quot;The Book&quot;</a></li>
<li><a href="https://rust-unofficial.github.io/too-many-lists/">Learn Rust With Entirely Too Many Linked Lists</a>
is a good way to learn Rust's ownership system and its
implications.</li>
</ul>
<h2 id="vs-code-setup"><a class="header" href="#vs-code-setup">VS Code Setup</a></h2>
<p>We recommend using VS Code with the <code>rust-analyzer</code> extension (and NOT the
<code>Rust</code> extension). To enable the pre-release version of <code>rust-analyzer</code>
(required by some new nightly syntax we use, at least until 2022-03-14), click
the &quot;Switch to Pre-Release Version&quot; button next to the uninstall button.</p>
<h2 id="hydroflow-setup"><a class="header" href="#hydroflow-setup">Hydroflow Setup</a></h2>
<p>The easiest way to get started with Hydroflow is to clone and work in the
repository directly. You should fork the repository if you want to push your
changes.</p>
<pre><code class="language-bash">git clone git@github.com:hydro-project/hydroflow.git
</code></pre>
<p>Hydroflow requires nightly Rust, but the repo is already configured for it via
<code>rust-toolchain.toml</code>.</p>
<p>We can then open the repo in VS Code or IDE of your choice. In VS Code, <code>rust-analyzer</code>
will provide inline type and error messages, code completion, etc.</p>
<h2 id="development"><a class="header" href="#development">Development</a></h2>
<p>The easiest way to try Hydroflow is with an &quot;example&quot;, found in the
<a href="https://github.com/hydro-project/hydroflow/tree/main/hydroflow/examples"><code>hydroflow/examples</code> folder</a>.
These examples are included via the <a href="https://github.com/hydro-project/hydroflow/blob/main/hydroflow/Cargo.toml"><code>hydroflow/Cargo.toml</code> file</a>,
so make sure to add your example there if you create a new one. The simplest
example is <a href="https://github.com/hydro-project/hydroflow/blob/main/hydroflow/examples/graph_reachability/main.rs"><code>graph_reachability</code></a>.</p>
<p>The Hydroflow repository is set up as a <a href="https://doc.rust-lang.org/book/ch14-03-cargo-workspaces.html">workspace</a>,
i.e. a repo containing a bunch of separate packages, <code>hydroflow</code> is just the
main one. So if you want to work in a proper separate cargo package, you can
create one and add it into the <a href="https://github.com/hydro-project/hydroflow/blob/main/Cargo.toml">root <code>Cargo.toml</code></a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="simplest-example"><a class="header" href="#simplest-example">Simplest Example</a></h1>
<blockquote>
<p>In this example we will cover:</p>
<ul>
<li>How to embed a Hydroflow program spec inside Rust </li>
<li>How to execute the Hydroflow program</li>
<li>Two simple Hydroflow operators: <code>source_iter</code> and <code>for_each</code></li>
</ul>
</blockquote>
<p>Lets start out with the simplest possible Hydroflow program, which prints out
the numbers in <code>0..10</code>.</p>
<pre><pre class="playground"><code class="language-rust">use hydroflow::hydroflow_syntax;

pub fn main() {
    let mut flow = hydroflow_syntax! {
        source_iter(0..10) -&gt; for_each(|n| println!(&quot;Hello {}&quot;, n));
    };

    flow.run_available();
}
</code></pre></pre>
<p>And the output:</p>
<pre><code class="language-txt">Hello 0
Hello 1
Hello 2
Hello 3
Hello 4
Hello 5
Hello 6
Hello 7
Hello 8
Hello 9
</code></pre>
<p>Although this is a trivial program, it's useful to go through it line by line.</p>
<pre><code class="language-rust ignore">use hydroflow::hydroflow_syntax;
</code></pre>
<p>This import gives you everything you need from Hydroflow to write code with the 
<a href="./surface_syntax.html"><em>surface syntax</em></a>, which is the recommended way to interact
with Hydroflow.</p>
<p>Next, inside the main method we specify a flow by calling the 
<code>hydroflow_syntax!</code> macro. We assign the resulting <code>Hydroflow</code> instance to
a mutable variable <code>flow</code>––mutable because we will be changing its status when we run it.</p>
<pre><code class="language-rust ignore"><span class="boring">use hydroflow::hydroflow_syntax;
</span>pub fn main() {
    let mut flow = hydroflow_syntax! {
        source_iter(0..10) -&gt; for_each(|n| println!(&quot;Hello {}&quot;, n));
    };
</code></pre>
<p>The flow starts with a <a href="./surface_ops.gen.html#source_iter"><code>source_iter</code></a> operator that takes the Rust
iterator <code>0..10</code> and iterates it to emit the 
numbers 0 through 9, and passes them along the arrow <code>-&gt;</code> operator downstream to a 
<a href="./surface_ops.gen.html#for_each"><code>for_each</code></a> operator that invokes its closure argument to print each
item passed in.</p>
<p>Finally we run this flow via the <a href="https://hydro-project.github.io/hydroflow/doc/hydroflow/scheduled/graph/struct.Hydroflow.html#method.run_available"><code>run_available()</code> method</a>.</p>
<pre><code class="language-rust ignore">    flow.run_available();
}
</code></pre>
<p>Note that <code>run_available()</code> runs the Hydroflow graph until no more work is immediately
available. In this case running the graph drains the iterator completely, so no
more work will ever be available. But once we add in external inputs such as
network ingress then more work might appear later. The <a href="https://hydro-project.github.io/hydroflow/doc/hydroflow/scheduled/graph/struct.Hydroflow.html#method.run_epoch"><code>run_epoch()</code></a>,
<a href="https://hydro-project.github.io/hydroflow/doc/hydroflow/scheduled/graph/struct.Hydroflow.html#method.run_stratum"><code>run_stratum()</code></a>,
<a href="https://hydro-project.github.io/hydroflow/doc/hydroflow/scheduled/graph/struct.Hydroflow.html#method.run"><code>run()</code></a>,
and <a href="https://hydro-project.github.io/hydroflow/doc/hydroflow/scheduled/graph/struct.Hydroflow.html#method.run_async"><code>run_async()</code></a>
methods provide other ways to control the graph execution.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="simple-example"><a class="header" href="#simple-example">Simple Example</a></h1>
<blockquote>
<p>In this example we will cover some additional standard Hydroflow operators:</p>
<ul>
<li><a href="./surface_ops.gen.html#map"><code>map</code></a></li>
<li><a href="./surface_ops.gen.html#filter"><code>filter</code></a></li>
<li><a href="./surface_ops.gen.html#flatten"><code>flatten</code></a></li>
<li><a href="./surface_ops.gen.html#filter_map"><code>filter_map</code></a></li>
<li><a href="./surface_ops.gen.html#flat_map"><code>flat_map</code></a></li>
</ul>
</blockquote>
<p>Lets build on the simplest example to explore some of the operators available
in Hydroflow. You may be familiar with operators such as <a href="./surface_ops.gen.html#map"><code>map(...)</code></a>,
<a href="./surface_ops.gen.html#filter"><code>filter(...)</code></a>, <a href="./surface_ops.gen.html#flatten"><code>flatten</code>(...)</a>,
etc. from Rust iterators or from other programming languages, and these are
also available in Hydroflow.</p>
<pre><pre class="playground"><code class="language-rust">use hydroflow::hydroflow_syntax;

pub fn main() {
    let mut flow = hydroflow_syntax! {
        source_iter(0..10)
            -&gt; map(|n| n * n)
            -&gt; filter(|&amp;n| n &gt; 10)
            -&gt; map(|n| (n..=n+1))
            -&gt; flatten()
            -&gt; for_each(|n| println!(&quot;Howdy {}&quot;, n));
    };

    flow.run_available();
}
</code></pre></pre>
<p>Let's take this one operator at a time, starting after the <code>source_iter</code> operator we saw in the previous example.</p>
<ul>
<li>
<p><code>-&gt; map(|n| n * n)</code> transforms each element one-to-one as it flows through the subgraph.
In this case, we square each number. </p>
</li>
<li>
<p>Next, <code>-&gt; filter(|&amp;n| n &gt; 10)</code> only keeps any squared numbers that are greater than 10.</p>
</li>
<li>
<p>The subsequent <code>-&gt; map(|n| (n..=n+1))</code> uses standard Rust syntax to convert each number <code>n</code> into a
<a href="https://doc.rust-lang.org/std/ops/struct.RangeInclusive.html"><code>RangeInclusive</code></a>
[<code>n</code>, <code>n+1</code>]. </p>
</li>
<li>
<p>We then call <code>-&gt; flatten()</code> to convert the ranges back
into a stream of the individual numbers which they contain.</p>
</li>
<li>
<p>Finally we use the now-familiar <code>for_each</code> operator to print each number.</p>
</li>
</ul>
<p>We can also express the same program with more aggressive use of combination operators like
<a href="./surface_ops.gen.html#filtermap"><code>filter_map()</code></a> and <a href="./surface_ops.gen.html#flat_map"><code>flat_map()</code></a>. Hydroflow will compile these down to the same
machine code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use hydroflow::hydroflow_syntax;
</span> pub fn main() {
    let mut flow = hydroflow_syntax! {
        source_iter(0..10)
        -&gt; filter_map(|n| {
            let n2 = n * n;
            if n2 &gt; 10 {
                Some(n2)
            }
            else {
                None
            }
        })
        -&gt; flat_map(|n| (n..=n+1))
        -&gt; for_each(|n| println!(&quot;G'day {}&quot;, n))
    };

    flow.run_available();
}
</code></pre></pre>
<p>Results:</p>
<pre><code class="language-txt">G'day 16
G'day 17
G'day 25
G'day 26
G'day 36
G'day 37
G'day 49
G'day 50
G'day 64
G'day 65
G'day 81
G'day 82
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="an-example-with-streaming-input"><a class="header" href="#an-example-with-streaming-input">An Example With Streaming Input</a></h1>
<blockquote>
<p>In this example we will cover:</p>
<ul>
<li>the input <code>channel</code> concept, which streams data in from outside the Hydroflow spec</li>
<li>the <a href="./surface_ops.gen.html#source_stream"><code>source_stream</code></a> operator that brings channel input into Hydroflow</li>
<li>Rust syntax to programmatically send data to a (local) channel</li>
</ul>
</blockquote>
<p>In our previous examples, data came from within the Hydroflow spec, via Rust iterators and the <a href="./surface_ops.gen.html#source_iter"><code>source_iter</code></a> operator. In most cases, however, data comes from outside the Hydroflow spec. In this example, we'll see a simple version of this idea, with data being generated on the same machine and sent into the channel programmatically via Rust.</p>
<p>We start with a skeleton much like before:</p>
<pre><pre class="playground"><code class="language-rust">use hydroflow::hydroflow_syntax;

pub fn main() {
    let mut hydroflow = hydroflow_syntax! {
        // code will go here
    };

    hydroflow.run_available();
}
</code></pre></pre>
<p>To add a new external input
channel, we can use the <code>hydroflow::util::unbounded_channel()</code> function in Rust before we declare the Hydroflow spec:</p>
<pre><code class="language-rust  ignore">    let (input_example, example_recv) = hydroflow::util::unbounded_channel::&lt;usize&gt;();
</code></pre>
<p>Under the covers, this is a <a href="https://docs.rs/tokio/latest/tokio/sync/mpsc/fn.unbounded_channel.html">multiple-producer/single-consumer (<code>mpsc</code>) channel</a> provided by Rust's <a href="https://docs.rs/tokio/latest/tokio">tokio</a> library, which is usually the appropriate choice for an inbound Hydroflow stream.
Think of it as a high-performance &quot;mailbox&quot; that any sender can fill with well-typed data.</p>
<p>The Rust <code>::&lt;usize&gt;</code> syntax uses what is affectionately
called the &quot;turbofish&quot;, which is how type parameters (generic arguments) are
supplied to generic types and functions. In this case it specifies that this tokio channel
transmits items of type <code>usize</code>.
The returned <code>example_recv</code> value can be used via a <a href="./surface_ops.gen.html#source_stream"><code>source_stream</code></a>
to build a Hydroflow subgraph just like before. Here is the same program as before, but using the
input channel:</p>
<pre><pre class="playground"><code class="language-rust">use hydroflow::hydroflow_syntax;

pub fn main() {
   // Create our channel input
    let (input_example, example_recv) = hydroflow::util::unbounded_channel::&lt;usize&gt;();

    let mut flow = hydroflow_syntax! {
         source_stream(example_recv)
        -&gt; filter_map(|n: usize| {
            let n2 = n * n;
            if n2 &gt; 10 {
                Some(n2)
            }
            else {
                None
            }
        })
        -&gt; flat_map(|n| (n..=n+1))
        -&gt; for_each(|n| println!(&quot;Ahoj {}&quot;, n))
    };

    println!(&quot;A&quot;);
    input_example.send(1).unwrap();
    input_example.send(0).unwrap();
    input_example.send(2).unwrap();
    input_example.send(3).unwrap();
    input_example.send(4).unwrap();
    input_example.send(5).unwrap();

    flow.run_available();

    println!(&quot;B&quot;);
    input_example.send(6).unwrap();
    input_example.send(7).unwrap();
    input_example.send(8).unwrap();
    input_example.send(9).unwrap();
    flow.run_available();
}
</code></pre></pre>
<pre><code class="language-txt">A
Ahoj 16
Ahoj 17
Ahoj 25
Ahoj 26
B
Ahoj 36
Ahoj 37
Ahoj 49
Ahoj 50
Ahoj 64
Ahoj 65
Ahoj 81
Ahoj 82
</code></pre>
<p>At the bottom we can see how to programatically supply <code>usize</code>-typed inputs with the tokio 
<code>.send()</code> method.  We call Rust's <code>.unwrap()</code> method to ignore the error messages from 
<code>.send()</code> in this simple case.  In later examples we'll see how to 
allow for data coming in over a network.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="graph-neighbors"><a class="header" href="#graph-neighbors">Graph Neighbors</a></h1>
<blockquote>
<p>In this example we cover:</p>
<ul>
<li>Our first multi-input operator, <a href="./surface_ops.gen.html#join"><code>join</code></a></li>
<li>The <a href="./surface_ops.gen.html#unique"><code>unique</code></a> operator for removing duplicates from a stream</li>
<li>A first exposure to the concepts of <em>strata</em> and <em>epochs</em></li>
</ul>
</blockquote>
<p>So far all the operators we've used have one input and one output and therefore
create a linear flow of operators. Let's now take a look at a Hydroflow program containing
an operator which has multiple inputs; in the following examples we'll extend this to
multiple outputs.</p>
<p>To motivate this, we'll build a simple flow-based algorithm for the problem of <em>graph neighbors</em>. 
Given an abstract graph -- represented as data in the form of a streaming list of edges -- which 
vertices can be reached from a vertex passed in as the <code>origin</code>? It turns out this is fairly 
naturally represented as a dataflow program. </p>
<blockquote>
<p><strong>Note on terminology</strong>: In each of the next few examples, we're going to write a Hydroflow program (a dataflow graph) to process data that itself represents some other graph! To avoid confusion, in these examples, we'll refer to the Hydroflow program as a &quot;flow&quot; or &quot;program&quot;, and the data as a &quot;graph&quot; of &quot;edges&quot; and &quot;vertices&quot;.</p>
</blockquote>
<p>To work our way up to graph reachability, we'll first start with a simple flow that finds
graph <em>neighbors</em>: vertices that are just one hop away. </p>
<p>Our first Hydroflow program will take
our initial <code>origin</code> vertex as one input, and join it another input that streams in all the edges---this 
join will stream out the vertices that are one hop (edge) away from the starting vertex. </p>
<p>Here is an <em>intuitive</em> diagram of that dataflow program (we'll see complete, autogenerated Hydroflow diagrams
below):</p>
<pre class="mermaid">graph TD
  subgraph sources
    01[Stream of Edges]
  end
  subgraph neighbors of origin
    00[Origin Vertex]
    20(&quot;V ⨝ E&quot;)
    40[Output]

    00 --&gt; 20
    
    01 ---&gt; 20
    20 --&gt; 40
    
  end
</pre>
<p>Lets take a look at some Hydroflow code that implements the program:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use hydroflow::hydroflow_syntax;
</span>pub fn main() {
    // An edge in the input data = a pair of `usize` vertex IDs.
    let (pairs_send, pairs_recv) = hydroflow::util::unbounded_channel::&lt;(usize, usize)&gt;();

    let mut flow = hydroflow_syntax! {
        // inputs: the origin vertex (vertex 0) and stream of input edges
        origin = source_iter(vec![0]);
        stream_of_edges = source_stream(pairs_recv);

        // the join
        my_join = join() -&gt; flat_map(|(src, (_, dst))| [src, dst]);
        origin -&gt; map(|v| (v, ())) -&gt; [0]my_join;
        stream_of_edges -&gt; [1]my_join;

        // the output
        my_join -&gt; unique() -&gt; for_each(|n| println!(&quot;Reached: {}&quot;, n));
    };

    println!(
        &quot;{}&quot;,
        flow.serde_graph()
            .expect(&quot;No graph found, maybe failed to parse.&quot;)
            .to_mermaid()
    );
    pairs_send.send((0, 1)).unwrap();
    pairs_send.send((2, 4)).unwrap();
    pairs_send.send((3, 4)).unwrap();
    pairs_send.send((1, 2)).unwrap();
    pairs_send.send((0, 3)).unwrap();
    pairs_send.send((0, 3)).unwrap();
    flow.run_available();
}
</code></pre></pre>
<p>And the output:</p>
<pre><code class="language-txt">Reached: 0
Reached: 3
Reached: 1
</code></pre>
<p>That looks right: the edges we &quot;sent&quot; into the flow that start at <code>0</code> are 
<code>(0, 1)</code> and <code>(0, 3)</code>.</p>
<p>As for the code itself, we start out with the origin vertex, <code>0</code>,
and the stream of edges coming in:</p>
<pre><code class="language-rust ignore">    origin = source_iter(vec![0]);
    stream_of_edges = source_stream(pairs_recv);
</code></pre>
<p>The Rust syntax <code>vec![0]</code> constructs a vector with a single element, <code>0</code>, which we iterate
over using <code>source_iter</code>.</p>
<p>We then set up a <a href="./surface_ops.gen.html#join"><code>join()</code></a> that we
name <code>my_join</code>, which acts like a SQL inner join. 
First, note the syntax for passing data into a subflow with multiple inputs requires us to <em>prepend</em> 
an input index (starting at <code>0</code>) in square brackets to the multi-input variable name or operator.  In this example we have <code>-&gt; [0]my_join</code>
and <code>-&gt; [1]my_join</code>.</p>
<p>Hydroflow's <code>join()</code> API requires
a little massaging of its inputs to work properly.
The inputs must be of the form of a pair of elements <code>(K, V1)</code>
and <code>(K, V2)</code>, and the operator joins them on equal keys <code>K</code> and produces an
output of <code>(K, (V1, V2))</code> elements. In this case we only want to join on the key <code>v</code> and
don't have any corresponding value, so we feed <code>origin</code> through a <a href="./surface_ops.gen.html#map"><code>map()</code></a>
to generate <code>(v, ())</code> elements as the first join input. </p>
<pre><code class="language-rust ignore">    my_join = join() -&gt; map(|(_x, (_y, z))| z);
    origin -&gt; map(|v| (v, ())) -&gt; [0]my_join;
    stream_of_edges -&gt; [1]my_join;
</code></pre>
<p>The <code>stream_of_edges</code> are <code>(src, dst)</code> pairs,
so the join's output is <code>(src, ((), dst))</code> where <code>dst</code> are new neighbor
vertices. So the <code>my_join</code> variable feeds the output of the join through a <code>flat_map</code> to extract the pairs into 2-item arrays, which are flattened to give us a list of all vertices reached.
Finally we print the neighbor vertices as follows:</p>
<pre><code class="language-rust ignore">    my_join -&gt; unique() -&gt; for_each(|n| println!(&quot;Reached: {}&quot;, n));
</code></pre>
<p>The <a href="./surface_ops.gen.html#unique">unique</a> operator removes duplicates from the stream to make things more readable. Note that <code>unique</code> does not run in a streaming fashion, which we will talk about more <a href="example_4_neighbors.html#strata-and-epochs">below</a>.</p>
<p>The remaining code runs the graph on example edge data. There's
also some extra code there, particularly <code>flow.serde_graph().expect(...).to_mermaid()</code> which lets us
generate a diagram rendered by <a href="https://mermaid-js.github.io/">Mermaid</a> showing
the structure of the graph:</p>
<pre class="mermaid">flowchart TB
    subgraph &quot;sg_1v1 stratum 0&quot;
        1v1[&quot;1v1 &lt;tt&gt;op_1v1: source_iter(vec! [0])&lt;/tt&gt;&quot;]
        2v1[&quot;2v1 &lt;tt&gt;op_2v1: source_stream(pairs_recv)&lt;/tt&gt;&quot;]
        5v1[&quot;5v1 &lt;tt&gt;op_5v1: map(| v | (v, ()))&lt;/tt&gt;&quot;]
        3v1[&quot;3v1 &lt;tt&gt;op_3v1: join()&lt;/tt&gt;&quot;]
        4v1[&quot;4v1 &lt;tt&gt;op_4v1: flat_map(| (src, (_, dst)) | [src, dst])&lt;/tt&gt;&quot;]
    end
    subgraph &quot;sg_2v1 stratum 1&quot;
        6v1[&quot;6v1 &lt;tt&gt;op_6v1: unique()&lt;/tt&gt;&quot;]
        7v1[&quot;7v1 &lt;tt&gt;op_7v1: for_each(| n | println! (&amp;quot;Reached: {}&amp;quot;, n))&lt;/tt&gt;&quot;]
    end

    8v1{&quot;handoff&quot;}

    1v1--&gt;5v1
    2v1--&gt;3v1
    3v1--&gt;4v1
    4v1--&gt;8v1
    5v1--&gt;3v1
    6v1--&gt;7v1
    8v1--&gt;6v1
</pre>
<p>Returning to the code, if you read the <code>pairs_send</code> calls carefully, you'll see that the example data 
has vertices (<code>2</code>, <code>4</code>) that are more than one hop away from <code>0</code>, which were
not output by our simple program. To extend this example to graph <em>reachability</em>, 
we need to recurse: find neighbors of our neighbors, neighbors of our neighbors' neighbors, and so on. In Hydroflow,
this is done by adding a loop to the flow, as we'll see in our <a href="example_5_reachability.html">next example</a>.</p>
<h2 id="strata-and-epochs"><a class="header" href="#strata-and-epochs">Strata and Epochs</a></h2>
<p>Before we proceed, note in the mermaid graph how Hydroflow separates the <code>unique</code> operator and its downstream dependencies into their own
<em>stratum</em> (plural: <em>strata</em>). The stratum boundary before <code>unique</code> ensures that all the values arrive before it executes, ensuring that all duplicates are eliminated. </p>
<p>Hydroflow runs each stratum
in order, one at a time, ensuring all values are computed
before moving on to the next stratum. Between strata we see a <em>handoff</em>, which logically buffers the 
output of the first stratum, and delineates the separation of execution between the 2 strata.</p>
<p>After all strata are run, Hydroflow returns to the first stratum; this begins the next <em>epoch</em>. This doesn't really matter for this example, but it is important for long-running Hydroflow services that accept input from the outside world.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="graph-reachability"><a class="header" href="#graph-reachability">Graph Reachability</a></h1>
<blockquote>
<p>In this example we cover:</p>
<ul>
<li>Implementing a recursive algorithm (graph reachability) via cyclic dataflow</li>
<li>Operators to merge data from multiple inputs (<a href="./surface_ops.gen.html#merge"><code>merge</code></a>), and send data to multiple outputs (<a href="./surface_ops.gen.html#tee"><code>tee</code></a>)</li>
<li>An example of how a cyclic dataflow in one stratum executes to completion before starting the next stratum. </li>
</ul>
</blockquote>
<p>To expand from graph neighbors to graph reachability, we want to find vertices that are connected not just to <code>origin</code>,
but also to vertices reachable <em>transitively</em> from <code>origin</code>. Said differently, a vertex is reachable from <code>origin</code> if it is
one of two cases: </p>
<ol>
<li>a neighbor of <code>origin</code> <em>or</em> </li>
<li>a neighbor of some other vertex that is itself reachable from <code>origin</code>. </li>
</ol>
<p>It turns out this is a very small change to our Hydroflow program! Essentially we want to take <em>all</em> the reached vertices we found in our graph neighbors program,
and treat them recursively just as we treated <code>origin</code>.
To do this in a language like Hydroflow, we introduce a cycle in the flow:
we take the join output and have it
flow back into the join input. The modified intuitive graph looks like this:</p>
<pre class="mermaid">graph TD
  subgraph sources
    01[Stream of Edges]
  end
  subgraph reachable from origin
    00[Origin Vertex]
    10[Reached Vertices]
    20(&quot;V ⨝ E&quot;)
    40[Output]

    00 --&gt; 10
    10 --&gt; 20
    20 --&gt; 10

    01 --&gt; 20
    20 --&gt; 40
    
  end
</pre>
<p>Note that we added a <code>Reached Vertices</code> box to the diagram to merge the two inbound edges corresponding to our 
two cases above. Similarly note that the join box <code>V ⨝ E</code> now has two <em>outbound</em> edges; the sketch omits the operator 
to copy (&quot;tee&quot;) the output along 
two paths.</p>
<p>Now lets look at a modified version of our <a href="example_4_neighbors.html">graph neighbor</a> code that implements this full program, including the loop as well as the Hydroflow <a href="./surface_ops.gen.html#merge"><code>merge</code></a> and <a href="./surface_ops.gen.html#tee"><code>tee</code></a>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use hydroflow::hydroflow_syntax;
</span>pub fn main() {
    // An edge in the input data = a pair of `usize` vertex IDs.
    let (pairs_send, pairs_recv) = hydroflow::util::unbounded_channel::&lt;(usize, usize)&gt;();

    let mut flow = hydroflow_syntax! {
        // inputs: the origin vertex (vertex 0) and stream of input edges
        origin = source_iter(vec![0]);
        stream_of_edges = source_stream(pairs_recv);
        reached_vertices = merge();
        origin -&gt; [0]reached_vertices;

        // the join
        my_join_tee = join() -&gt; flat_map(|(src, ((), dst))| [src, dst]) -&gt; tee();
        reached_vertices -&gt; map(|v| (v, ())) -&gt; [0]my_join_tee;
        stream_of_edges -&gt; [1]my_join_tee;

        // the loop and the output
        my_join_tee[0] -&gt; [1]reached_vertices;
        my_join_tee[1] -&gt; unique() -&gt; for_each(|x| println!(&quot;Reached: {}&quot;, x));
    };

    println!(
        &quot;{}&quot;,
        flow.serde_graph()
            .expect(&quot;No graph found, maybe failed to parse.&quot;)
            .to_mermaid()
    );
    pairs_send.send((0, 1)).unwrap();
    pairs_send.send((2, 4)).unwrap();
    pairs_send.send((3, 4)).unwrap();
    pairs_send.send((1, 2)).unwrap();
    pairs_send.send((0, 3)).unwrap();
    pairs_send.send((0, 3)).unwrap();
    flow.run_available();
}
</code></pre></pre>
<p>And now we get the full set of vertices reachable from <code>0</code>:</p>
<pre><code class="language-txt">Reached: 3
Reached: 0
Reached: 2
Reached: 4
Reached: 1
</code></pre>
<p>Let's review the significant changes here. First, in setting up the inputs we have the 
addition of the <code>reached_vertices</code> variable, which uses the <a href="./surface_ops.gen.html#merge">merge()</a> 
op to merge the output of two operators into one. 
We route the <code>origin</code> vertex into it as one input right away:</p>
<pre><code class="language-rust ignore">    reached_vertices = merge();
    origin -&gt; [0]reached_vertices;
</code></pre>
<p>Note the square-bracket syntax for differentiating the multiple inputs to <code>merge()</code>
is the same as that of <code>join()</code> (except that merge can have an unbounded number of inputs,
whereas <code>join()</code> is defined to only have two.)</p>
<p>Now, <code>join()</code> is defined to only have one output. In our program, we want to copy 
the joined output 
output to two places: to the original <code>for_each</code> from above to print output, and <em>also</em> 
back to the <code>merge</code> operator we called <code>reached_vertices</code>.
We feed the <code>join()</code> output 
through a <code>flat_map()</code> as before, and then we feed the result into a <a href="./surface_ops.gen.html#tee"><code>tee()</code></a> operator,
which is the mirror image of <code>merge()</code>:  instead of merging many inputs to one output, 
it copies one input to many different outputs.  Each input element is <em>cloned</em>, in Rust terms, and
given to each of the outputs. The syntax for the outputs of <code>tee()</code> mirrors that of merge: we <em>append</em> 
an output index in square brackets to the <code>tee</code> or variable. In this example we have
<code>my_join_tee[0] -&gt;</code> and <code>my_join_tee[1] -&gt;</code>.</p>
<p>Finally, we process the output of the <code>join</code> as passed through the <code>tee</code>.
One branch pushes reached vertices back up into the <code>reached_vertices</code> variable (which begins with a <code>merge</code>), while the other
prints out all the reached vertices as in the simple program.</p>
<pre><code class="language-rust ignore">        my_join_tee[0] -&gt; [1]reached_vertices;
        my_join_tee[1] -&gt; for_each(|x| println!(&quot;Reached: {}&quot;, x));
</code></pre>
<p>Note the syntax for differentiating the <em>outputs</em> of a <code>tee()</code> is symmetric to that of <code>merge()</code>, 
showing up to the right of the variable rather than the left.</p>
<p>Below is the diagram rendered by <a href="https://mermaid-js.github.io/">mermaid</a> showing
the structure of the full flow:</p>
<pre class="mermaid">flowchart TB
    subgraph &quot;sg_1v1 stratum 0&quot;
        1v1[&quot;1v1 &lt;tt&gt;op_1v1: source_iter(vec! [0])&lt;/tt&gt;&quot;]
        2v1[&quot;2v1 &lt;tt&gt;op_2v1: source_stream(edges_recv)&lt;/tt&gt;&quot;]
        3v1[&quot;3v1 &lt;tt&gt;op_3v1: merge()&lt;/tt&gt;&quot;]
        7v1[&quot;7v1 &lt;tt&gt;op_7v1: map(| v | (v, ()))&lt;/tt&gt;&quot;]
        4v1[&quot;4v1 &lt;tt&gt;op_4v1: join()&lt;/tt&gt;&quot;]
        5v1[&quot;5v1 &lt;tt&gt;op_5v1: flat_map(| (src, ((), dst)) | [src, dst])&lt;/tt&gt;&quot;]
        6v1[&quot;6v1 &lt;tt&gt;op_6v1: tee()&lt;/tt&gt;&quot;]
    end
    subgraph &quot;sg_2v1 stratum 1&quot;
        8v1[&quot;8v1 &lt;tt&gt;op_8v1: unique()&lt;/tt&gt;&quot;]
        9v1[&quot;9v1 &lt;tt&gt;op_9v1: for_each(| x | println! (&amp;quot;Reached: {}&amp;quot;, x))&lt;/tt&gt;&quot;]
    end

    10v1{&quot;handoff&quot;}
    11v1{&quot;handoff&quot;}

    1v1--&gt;3v1
    2v1--&gt;4v1
    3v1--&gt;7v1
    4v1--&gt;5v1
    5v1--&gt;6v1
    6v1--&gt;10v1
    6v1--&gt;11v1
    7v1--&gt;4v1
    8v1--&gt;9v1
    10v1--&gt;3v1
    11v1--&gt;8v1
</pre>
<p>This is similar to the flow for graph neighbors, but has a few more operators that make it look
more complex. In particular, it includes the <code>merge</code> and <code>tee</code> operators, and a cycle-forming back-edge 
that passes through an auto-generated <code>handoff</code> operator. This <code>handoff</code> is not a stratum boundary (after all, it connects stratum 0 to itself!) Rather, it represents a compilation boundary: the compiled code that Hydroflow generates is acyclic (as discussed in the <a href="./architecture.html">Architecture Chapter</a>), so these handoffs tell the runtime to iterate on the acyclic code of a stratum until there is no new output from the stratum.</p>
<p>Meanwhile, note in the mermaid diagram that there is once again a stratum boundary between the stratum 0 with its recursive loop, and stratum 1 that computes <code>unique</code>. This means that Hydroflow will first run the loop continuously until all the transitive reached vertices are found, before moving on to compute the unique reached vertices.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="graph-un-reachability"><a class="header" href="#graph-un-reachability">Graph Un-Reachability</a></h1>
<blockquote>
<p>In this example we cover:</p>
<ul>
<li>Extending a program with additional downstream logic.</li>
<li>Hydroflow's (<a href="./surface_ops.gen.html#merge"><code>difference</code></a>) operator</li>
<li>Further examples of automatic stratification.</li>
</ul>
</blockquote>
<p>Our next example builds on the previous by finding vertices that are <em>not</em> reachable. To do this, we need to capture the set <code>all_vertices</code>, and use a <a href="./surface_ops.gen.html#difference">difference</a> operator to form the difference between that set of vertices and <code>reachable_vertices</code>.</p>
<p>Essentially we want a flow like this:</p>
<pre class="mermaid">graph TD
  subgraph sources
    01[Stream of Edges]
  end
  subgraph reachable from origin
    00[Origin Vertex]
    10[Reached Vertices]
    20(&quot;V ⨝ E&quot;)

    00 --&gt; 10
    10 --&gt; 20
    20 --&gt; 10

    01 --&gt; 20
  end
  subgraph unreachable
    15[All Vertices]
    30(All - Reached)
    01 ---&gt; 15
    15 --&gt; 30
    10 --&gt; 30
    30 --&gt; 40
   end
40[Output]
</pre>
<p>This is a simple augmentation of our previous example. Here's the code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use hydroflow::hydroflow_syntax;
</span>pub fn main() {
    // An edge in the input data = a pair of `usize` vertex IDs.
    let (pairs_send, pairs_recv) = hydroflow::util::unbounded_channel::&lt;(usize, usize)&gt;();

    let mut flow = hydroflow_syntax! {
        origin = source_iter(vec![0]);
        stream_of_edges = source_stream(pairs_recv) -&gt; tee();
        reached_vertices = merge()-&gt;tee();
        origin -&gt; [0]reached_vertices;

        // the join for reachable vertices
        my_join = join() -&gt; flat_map(|(src, ((), dst))| [src, dst]);
        reached_vertices[0] -&gt; map(|v| (v, ())) -&gt; [0]my_join;
        stream_of_edges[1] -&gt; [1]my_join;

        // the loop
        my_join -&gt; [1]reached_vertices;

        // the difference all_vertices - reached_vertices
        all_vertices = stream_of_edges[0]
          -&gt; flat_map(|(src, dst)| [src, dst]) -&gt; tee();
        unreached_vertices = difference();
        all_vertices[0] -&gt; [pos]unreached_vertices;
        reached_vertices[1] -&gt; [neg]unreached_vertices;

        // the output
        all_vertices[1] -&gt; unique() -&gt; for_each(|v| println!(&quot;Received vertex: {}&quot;, v));
        unreached_vertices -&gt; for_each(|v| println!(&quot;unreached_vertices vertex: {}&quot;, v));
    };

    println!(
        &quot;{}&quot;,
        flow.serde_graph()
            .expect(&quot;No graph found, maybe failed to parse.&quot;)
            .to_mermaid()
    );

    pairs_send.send((5, 10)).unwrap();
    pairs_send.send((0, 3)).unwrap();
    pairs_send.send((3, 6)).unwrap();
    pairs_send.send((6, 5)).unwrap();
    pairs_send.send((11, 12)).unwrap();
    flow.run_available();
}
</code></pre></pre>
<p>Notice that we are now sending in some new pairs to test this code. The output should be:</p>
<pre><code class="language-txt">Received vertex: 12
Received vertex: 6
Received vertex: 11
Received vertex: 0
Received vertex: 5
Received vertex: 10
Received vertex: 3
unreached_vertices vertex: 12
unreached_vertices vertex: 11
</code></pre>
<p>Let's review the changes, all of which come at the end of the program. First, 
we remove code to print <code>reached_vertices</code>. Then we define <code>all_vertices</code> to be
the vertices that appear in any edge (using familiar <code>flat_map</code> code from the previous 
examples.) In the last few lines, we wire up a 
<a href="./surface_ops.gen.html#difference">difference</a> operator
to compute the difference between <code>all_vertices</code> and <code>reached_vertices</code>; note 
how we wire up the <code>pos</code> and <code>neg</code> inputs to the <code>difference</code> operator! 
Finally we print both <code>all_vertices</code> and <code>unreached_vertices</code>.</p>
<p>The auto-generated mermaid looks like so:</p>
<pre class="mermaid">flowchart TB
    subgraph &quot;sg_1v1 stratum 0&quot;
        1v1[&quot;1v1 &lt;tt&gt;op_1v1: source_iter(vec! [0])&lt;/tt&gt;&quot;]
        8v1[&quot;8v1 &lt;tt&gt;op_8v1: map(| v | (v, ()))&lt;/tt&gt;&quot;]
        6v1[&quot;6v1 &lt;tt&gt;op_6v1: join()&lt;/tt&gt;&quot;]
        7v1[&quot;7v1 &lt;tt&gt;op_7v1: flat_map(| (src, ((), dst)) | [src, dst])&lt;/tt&gt;&quot;]
        4v1[&quot;4v1 &lt;tt&gt;op_4v1: merge()&lt;/tt&gt;&quot;]
        5v1[&quot;5v1 &lt;tt&gt;op_5v1: tee()&lt;/tt&gt;&quot;]
    end
    subgraph &quot;sg_2v1 stratum 0&quot;
        2v1[&quot;2v1 &lt;tt&gt;op_2v1: source_stream(pairs_recv)&lt;/tt&gt;&quot;]
        3v1[&quot;3v1 &lt;tt&gt;op_3v1: tee()&lt;/tt&gt;&quot;]
        9v1[&quot;9v1 &lt;tt&gt;op_9v1: flat_map(| (src, dst) | [src, dst])&lt;/tt&gt;&quot;]
        10v1[&quot;10v1 &lt;tt&gt;op_10v1: tee()&lt;/tt&gt;&quot;]
    end
    subgraph &quot;sg_3v1 stratum 1&quot;
        12v1[&quot;12v1 &lt;tt&gt;op_12v1: unique()&lt;/tt&gt;&quot;]
        13v1[&quot;13v1 &lt;tt&gt;op_13v1: for_each(| v | println! (&amp;quot;Received vertex: {}&amp;quot;, v))&lt;/tt&gt;&quot;]
    end
    subgraph &quot;sg_4v1 stratum 1&quot;
        11v1[&quot;11v1 &lt;tt&gt;op_11v1: difference()&lt;/tt&gt;&quot;]
        14v1[&quot;14v1 &lt;tt&gt;op_14v1: for_each(| v | println! (&amp;quot;unreached_vertices vertex: {}&amp;quot;, v))&lt;/tt&gt;&quot;]
    end

    15v1{&quot;handoff&quot;}
    16v1{&quot;handoff&quot;}
    17v1{&quot;handoff&quot;}
    18v1{&quot;handoff&quot;}
    19v1{&quot;handoff&quot;}

    1v1--&gt;4v1
    2v1--&gt;3v1
    3v1--&gt;16v1
    3v1--&gt;9v1
    4v1--&gt;5v1
    5v1--&gt;15v1
    5v1--&gt;18v1
    6v1--&gt;7v1
    7v1--&gt;4v1
    8v1--&gt;6v1
    9v1--&gt;10v1
    10v1--&gt;17v1
    10v1--&gt;19v1
    11v1--&gt;14v1
    12v1--&gt;13v1
    15v1--&gt;8v1
    16v1--&gt;6v1
    17v1--&gt;11v1
    18v1--&gt;11v1
    19v1--&gt;12v1
</pre>
<p>If you look carefully, you'll see two subgraphs labeled with <code>stratum 0</code>, and two with
<code>stratum 1</code>. All the subgraphs labeled <code>stratum 0</code> are run first to completion, 
and then all the subgraphs labeled <code>stratum 1</code> are run. This captures the requirements of the <code>unique</code> and <code>difference</code> operators used in the lower subgraphs: each has to wait for its full inputs before it can start producing output.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="networked-services-1-echoserver"><a class="header" href="#networked-services-1-echoserver">Networked Services 1: EchoServer</a></h1>
<blockquote>
<p>In this example we cover:</p>
<ul>
<li>A standard project template for building networked Hydroflow services.</li>
<li>Rust's <code>clap</code> crate for command-line options</li>
<li>Defining message types</li>
<li>Using network sources and sinks with built-in serde.</li>
<li>The <code>source_stdin</code> source</li>
<li>Long-running services via <code>run_async</code></li>
</ul>
</blockquote>
<p>Our examples up to now have been simple single-node programs, to get us comfortable with Hydroflow's
surface syntax. But the whole point of Hydroflow is to help us write distributed programs or services that run on a cluster of machines!</p>
<p>In this example we'll build the &quot;hello, world&quot; of distributed systems -- a simple echo server. It will listen on a UDP port,
and send back a copy of any message it receives, with a timestamp. We will also build a client to 
accept strings from the command line, send them to the echo server, and print responses.</p>
<p>Full code for this example can be found in <code>hydroflow/hydroflow/examples/echoserver</code>. This example can 
serve as a template for many networked Hydroflow services.</p>
<p>Generally the directory structure we'll use will be as follows:</p>
<pre><code class="language-txt">project/README.md           # documentation
project/Cargo.toml          # package and dependency info
project/src/main.rs         # main function
project/src/protocol.rs     # message types exchanged between roles
project/src/helpers.rs      # helper functions used by all roles
project/src/&lt;roleA&gt;.rs      # service definition for role A (e.g. server)
project/src/&lt;roleB&gt;.rs      # service definition for role B (e.g. client)
</code></pre>
<p>In this example, the roles we'll be using are <code>Client</code> and <code>Server</code>, but you can imagine different roles depending on the structure of your service or application.</p>
<h2 id="mainrs"><a class="header" href="#mainrs">main.rs</a></h2>
<p>We start with a <code>main</code> function that parses command-line options, and invokes the appropriate
role-specific service.
After a prelude of imports, we start by defining an <code>enum</code> for the <code>Role</code>s that the service supports. </p>
<pre><code class="language-rust  ignore">use clap::{ArgEnum, Parser};
use client::run_client;
use hydroflow::tokio;
use hydroflow::util::{bind_udp_socket, ipv4_resolve};
use server::run_server;

mod client;
mod protocol;
mod server;

#[derive(Clone, ArgEnum, Debug)]
enum Role {
    Client,
    Server,
}
</code></pre>
<p>Following that, we use Rust's <a href="https://docs.rs/clap/latest/clap/"><code>clap</code></a> (Command Line Argument Parser) crate to parse command-line options:</p>
<pre><code class="language-rust ignore">#[derive(Parser, Debug)]
struct Opts {
    #[clap(arg_enum, long)]
    role: Role,
    #[clap(long)]
    addr: Option&lt;String&gt;,
    #[clap(long)]
    server_addr: String,
}
</code></pre>
<p>This sets up 3 command-line options: <code>role</code>, <code>addr</code>, and <code>server_addr</code>. The <code>addr</code> option is optional, but the <code>role</code> and <code>server_addr</code> options are required. The <code>clap</code> crate will parse the command-line options and populate the <code>Opts</code> struct with the values.</p>
<p>This brings us to the <code>main</code> function itself. It is prefaced by a <code>#[tokio::main]</code> attribute, which is a macro that sets up the tokio runtime. This is necessary because Hydroflow uses the tokio runtime for asynchronous execution.</p>
<pre><code class="language-rust ignore">#[tokio::main]
async fn main() {
    // parse command line arguments
    let opts = Opts::parse();
</code></pre>
<p>After parsing the command line arguments, we get into invoking the client or server code. Before we do so, we set up some Rust-based networking. Specifically, in both cases we will need to allocate a UDP socket that is used for both sending and receiving messages. We do this by calling the async <code>bind_udp_socket</code> function, which is defined in the <code>hydroflow/src/util</code> module. As an async function it returns a <code>Future</code>, so requires appending <code>.await</code>; the function returns a pair of type <code>(UdpSink, UdpSource)</code>. These are the types that we'll use in Hydroflow to send and receive messages. (Note: your IDE might expand out the <code>UdpSink</code> and <code>UdpSource</code> traits to their more verbose definitions. This is fine; you can ignore for now.)</p>
<p>For the server case, all that's left is to invoke <code>run_server</code> and pass it the network information. Note that the server is also asynchronous, so we append <code>.await</code> to that call as well. The program will block on this call until the server is done (which should only happen when it fails).</p>
<pre><code class="language-rust ignore">    // depending on the role, pass in arguments to the right function
    match opts.role {
        Role::Server =&gt; {
            // allocate `outbound` and `inbound` sockets
            let (outbound, inbound) = bind_udp_socket(opts.server_addr.clone()).await;
            // run the server
            run_server(outbound, inbound, opts.graph.clone()).await;
        }
</code></pre>
<p>In the client case, we need one more piece of information passed down: the address of the server. We get this by calling the <code>ipv4_resolve</code> function, which is also defined in the <code>hydroflow/src/util</code> module. This function takes a string and returns a <code>SocketAddr</code> type, which is the address/port structure that  <code>UdpSink</code> and <code>UdpSource</code> will use. Invoking <code>run_client</code> is similar to the server case, except that we pass in the server address as well.</p>
<pre><code class="language-rust ignore">        Role::Client =&gt; {
            // resolve the server's IP address
            let server_addr = ipv4_resolve(opts.server_addr.clone());
            // allocate `outbound` and `inbound` sockets
            let (outbound, inbound) = bind_udp_socket(opts.addr.clone().unwrap()).await;
            // run the client
            run_client(outbound, inbound, server_addr).await;
        }
    }
}
</code></pre>
<h2 id="protocolrs"><a class="header" href="#protocolrs">protocol.rs</a></h2>
<p>As a design pattern, it is natural in distributed Hydroflow programs to define various message types in a <code>protocol.rs</code> file with structures shared for use by all the Hydroflow logic across roles. In this simple example, we define only one message type: <code>EchoMsg</code>, and a simple struct with two fields: <code>payload</code> and <code>ts</code> (timestamp). The <code>payload</code> field is a string, and the <code>ts</code> field is a <code>DateTime&lt;Utc&gt;</code>, which is a type from the <a href="https://docs.rs/chrono/latest/chrono/"><code>chrono</code></a> crate. Note the various derived traits on <code>EchoMsg</code>—specifically <code>Serialize</code> and <code>Deserialize</code>—these are required for structs that we send over the network.</p>
<pre><code class="language-rust ignore">#[derive(PartialEq, Clone, Serialize, Deserialize, Debug)]
pub struct EchoMsg {
    pub payload: String,
    pub ts: DateTime&lt;Utc&gt;,
}
</code></pre>
<h1 id="serverrs"><a class="header" href="#serverrs">server.rs</a></h1>
<p>Things get interesting when we look at the <code>run_server</code> function. This function is the main entry point for the server. It takes as arguments the <code>outbound</code> and <code>inbound</code> sockets, and the <code>graph</code> type. The <code>outbound</code> and <code>inbound</code> sockets are the same ones that we allocated in <code>main.rs</code>. The <code>graph</code> type is an enum that we defined in <code>main.rs</code>, and is used to control whether Hydroflow emits a dataflow diagram.</p>
<p>After printing a cheery message, we get the surface syntax for the server, consisting of three short pipelines:</p>
<pre><code class="language-rust ignore">use crate::protocol::EchoMsg;
use chrono::prelude::*;
use hydroflow::hydroflow_syntax;
use hydroflow::scheduled::graph::Hydroflow;
use hydroflow::util::{UdpSink, UdpStream};
use std::net::SocketAddr;

pub(crate) async fn run_server(outbound: UdpSink, inbound: UdpStream) {
    println!(&quot;Server live!&quot;);


   let mut flow: Hydroflow = hydroflow_syntax! {
        // Inbound channel sharing
        inbound_chan = source_stream_serde(inbound) -&gt; tee();

        // Logic
        inbound_chan[0] -&gt; for_each(|(m, a): (EchoMsg, SocketAddr)| println!(&quot;Got {:?} from {:?}&quot;, m, a));
        inbound_chan[1] -&gt; map(|(EchoMsg { payload, .. }, addr)| (EchoMsg { payload, ts: Utc::now() }, addr))
            -&gt; dest_sink_serde(outbound);
    };
</code></pre>
<p>Lets take these one at a time. </p>
<p>The first pipeline, <code>inbound_chan</code> uses a source operator we have not seen before, <a href="./surface_ops.gen.html#source_stream_serde"><code>source_stream_serde()</code></a>. This is a streaming source like <code>source_stream</code>, but for network streams. It takes a <code>UdpSource</code> as an argument, and has a particular output type: a stream of <code>(T, SocketAddr)</code> pairs where <code>T</code> is some type that implements the <code>Serialize</code> and <code>Deserialize</code> traits, and <code>SocketAddr</code> is the network address of the sender of the item. In this case, <code>T</code> is <code>EchoMsg</code>, which we defined in <code>protocol.rs</code>, and the <code>SocketAddr</code> is the address of the client that sent the message. We pipe the result into a <code>tee()</code> for reuse.</p>
<p>The second pipeline is a simple <code>for_each</code> to print the messages received at the server.</p>
<p>The third and final pipeline constructs a response <code>EchoMsg</code> with the local timestamp copied in. It then pipes the result into a sink operator we have not seen before, <a href="./surface_ops.gen.html#dest_sink_serde"><code>dest_sink_serde()</code></a>. This is a sink operator like <code>dest_sink</code>, but for network streams. It takes a <code>UdpSink</code> as an argument, and requires a particular input type: a stream of <code>(T, SocketAddr)</code> pairs where <code>T</code> is some type that implements the <code>Serialize</code> and <code>Deserialize</code> traits, and <code>SocketAddr</code> is the network address of the destination. In this case, <code>T</code> is once again <code>EchoMsg</code>, and the <code>SocketAddr</code> is the address of the client that sent the original message.</p>
<p>The remaining line of code runs the server. The <code>run_async()</code> function is a method on the <code>Hydroflow</code> type. It is an async function, so we append <code>.await</code> to the call. The program will block on this call until the server is done.</p>
<pre><code class="language-rust ignore">    // run the server
    flow.run_async().await;
}
</code></pre>
<h2 id="clientrs"><a class="header" href="#clientrs">client.rs</a></h2>
<p>The client is as simple as the server, consisting only of two pipelines. The first uses another new source operator <a href="./surface_ops.gen.html#source_stdin"><code>source_stdin()</code></a>, which does what you might expect: streams lines of text as they arrive from <code>stdin</code> (i.e. as they are typed into a terminal). It then uses a <code>map</code> to construct an <code>EchoMsg</code> with the current timestamp. The result is piped into a sink operator <a href="./surface_ops.gen.html#dest_sink_serde"><code>dest_sink_serde()</code></a>, which sends the message to the server. The second operator is a <code>for_each</code> that prints the messages echoed back from the server.</p>
<pre><code class="language-rust ignore">use crate::protocol::EchoMsg;
use chrono::prelude::*;
use hydroflow::hydroflow_syntax;
use hydroflow::util::{UdpSink, UdpStream};
use std::net::SocketAddr;

pub(crate) async fn run_client(outbound: UdpSink, inbound: UdpStream, server_addr: SocketAddr) {
    println!(&quot;Attempting to connect to server at {:?}&quot;, server_addr);
    println!(&quot;Client live!&quot;);

    let mut flow = hydroflow_syntax! {
        // take stdin and send to server as an Echo::Message
        source_stdin() -&gt; map(|l| (EchoMsg{ payload: l.unwrap(), ts: Utc::now(), }, server_addr) )
            -&gt; dest_sink_serde(outbound);

        // receive and print messages
        source_stream_serde(inbound) -&gt; for_each(|(m, _a): (EchoMsg, SocketAddr) | println!(&quot;{:?}&quot;, m));
    };

    flow.run_async().await.unwrap();
}
</code></pre>
<h2 id="running-the-example"><a class="header" href="#running-the-example">Running the example</a></h2>
<p>As described in <code>hydroflow/hydroflow/example/echoserver/README.md</code>, we can run the server in one terminal, and the client in another. The server will print the messages it receives, and the client will print the messages it receives back from the server. The client and servers' `--server-addr' arguments need to match or this won't work!</p>
<p>Fire up the server in terminal 1:</p>
<pre><code class="language-console">% cargo run -p hydroflow --example echoserver -- --role server --server-addr localhost:12347
</code></pre>
<p>Then start the client in terminal 2 and type some messages!</p>
<pre><code class="language-console">% cargo run -p hydroflow --example echoserver -- --role client --addr localhost:9090 --server-addr localhost:12347
Attempting to connect to server at 127.0.0.1:12347
Client live!
This is a test 
EchoMsg { payload: &quot;This is a test&quot;, ts: 2022-12-12T23:42:13.053293Z }
This is the rest!
EchoMsg { payload: &quot;This is the rest!&quot;, ts: 2022-12-12T23:42:20.181371Z }
</code></pre>
<p>And have a look back at the server console!</p>
<pre><code class="language-console">Server live!
Got EchoMsg { payload: &quot;This is a test&quot;, ts: 2022-12-12T23:42:13.049499Z } from 127.0.0.1:9090
Got EchoMsg { payload: &quot;This is the rest!&quot;, ts: 2022-12-12T23:42:20.179337Z } from 127.0.0.1:9090
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concepts"><a class="header" href="#concepts">Concepts</a></h1>
<h2 id="dataflow-and-networking"><a class="header" href="#dataflow-and-networking">Dataflow and Networking</a></h2>
<p>Conventionally, dataflow systems provide a way to analyze and process data by
chaining functions (operators) together into pipelines. But with a change of
perspective, many computations can be represented as dataflow. Designing around
the flow of data naturally separates computation into easily parallelizable and
distributable pipelines.</p>
<p>Most dataflow systems provide opinionated mechanisms for running flows across
multiple machines. Hydroflow however aims to represent many more types of
computations besides just data processing. This includes networking protocols
like two-phase commit and Paxos. To this end, Hydroflow is unopinionated about
network communication. Additionally, Hydroflow provides the abstraction of only
a single node (single thread) of a system. To build up a distributed system,
the user must design each node to communicate with others as needed.</p>
<p>As development continues we will provide more utilities for common networking
use cases, but for now expect some manual management of IP addresses and
sockets.</p>
<h2 id="lattices"><a class="header" href="#lattices">Lattices</a></h2>
<h2 id="strata"><a class="header" href="#strata">Strata</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hydroflow-surface-syntax"><a class="header" href="#hydroflow-surface-syntax">Hydroflow Surface Syntax</a></h1>
<p>The natural way to write a Hydroflow program is using the <em>Surface Syntax</em> documented here. 
It is a chained <code>Iterator</code>-style syntax of operators built into Hydroflow that should be sufficient
for most uses. If you want lower-level access you can work with the <code>Core API</code> documented in the <a href="./architecture.html">Architecture</a> section.</p>
<p>In this chapter we go over the syntax piece by piece: how to <a href="./surface_embedding.html">embed surface syntax in Rust</a> and how to specify <a href="./surface_flows.html"><em>flows</em></a>, which consist of <a href="./surface_data.html"><em>data sources</em></a> flowing through <a href="./surface_ops.gen.html"><em>operators</em></a>.</p>
<!-- TODO(mingwei): In the [Hydroflow Types](surface_types.md) chapter we dive into the details of the data types that pass through flows. -->
<p>As a teaser, here is a Rust/Hydroflow &quot;HELLO WORLD&quot; program:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use hydroflow::hydroflow_syntax;

pub fn test_hello_world() {
    let mut df = hydroflow_syntax! {
        source_iter(vec![&quot;hello&quot;, &quot;world&quot;])
            -&gt; map(|x| x.to_uppercase()) -&gt; for_each(|x| println!(&quot;{}&quot;, x));
    };
    df.run_available();
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="embedding-a-flow-in-rust"><a class="header" href="#embedding-a-flow-in-rust">Embedding a Flow in Rust</a></h1>
<p>Hydroflow's surface syntax is typically used within a Rust program. (An interactive client and/or external language bindings are TBD.)</p>
<p>The surface syntax is embedded into Rust via a macro as follows</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use hydroflow::hydroflow_syntax;

pub fn example() {
    let mut flow = hydroflow_syntax! {
        // Hydroflow Surface Syntax goes here
    };
}
<span class="boring">}
</span></code></pre></pre>
<p>The resulting <code>flow</code> object is of type <code>Hydroflow</code>.</p>
<!-- TODO(mingwei): see the documentation on the
[Hydroflow Object](./hydroflow_object.md) for details on how to use the result. -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="flow-syntax"><a class="header" href="#flow-syntax">Flow Syntax</a></h1>
<p>Flows consist of named <em>operators</em> that are connected via flow <em>edges</em> denoted by <code>-&gt;</code>. The example below
uses the <a href="./surface_ops.gen.html#source_iter"><code>source_iter</code></a> operator to generate two strings from a Rust <code>vec</code>, the 
<a href="./surface_ops.gen.html#map"><code>map</code></a> operator to apply some Rust code to uppercase each string, and the <a href="./surface_ops.gen.html#for_each"><code>for_each</code></a> 
operator to print each string to stdout.</p>
<pre><code class="language-rust ignore">source_iter(vec![&quot;Hello&quot;, &quot;world&quot;]) 
    -&gt; map(|x| x.to_uppercase()) -&gt; for_each(|x| println!(&quot;{}&quot;, x));
</code></pre>
<p>Flows can be assigned to variable names for convenience. E.g, the above can be rewritten as follows:</p>
<pre><code class="language-rust ignore">upper_print = map(|x| x.to_uppercase()) -&gt; for_each(|x| println!(&quot;{}&quot;, x));
source_iter(vec![&quot;Hello&quot;, &quot;world&quot;]) -&gt; upper_print;
</code></pre>
<h2 id="operators-with-multiple-ports"><a class="header" href="#operators-with-multiple-ports">Operators with Multiple Ports</a></h2>
<p>Some operators have more than one input <em>port</em> that can be referenced by <code>-&gt;</code>. For example <a href="./surface_ops.gen.html#merge"><code>merge</code></a> 
merges the contents of many flows, so it can have an abitrary number of input ports. Some operators have multiple outputs, notably <a href="./surface_ops.gen.html#tee"><code>tee</code></a>,
which has an arbitrary number of outputs. </p>
<p>In the syntax, we distinguish input ports via an <em>indexing prefix</em> number
in square brackets before the operator name (e.g. <code>[0]merge(...)</code> and <code>[1]merge(...)</code>). We 
distinguish output ports by an <em>indexing suffix</em> (e.g. <code>tee[0]</code>). </p>
<p>Here is an example that tees one flow into two, handles each separately, and then merges them to print out the contents in both lowercase and uppercase:</p>
<pre><code class="language-rust ignore">source = source_iter(vec![&quot;Hello&quot;, &quot;world&quot;]) -&gt; tee();
print = merge() -&gt; for_each(|x| println!(&quot;{}&quot;, x));
source[0] -&gt; map(|x: &amp;str| x.to_uppercase()) -&gt; [0]print;
source[1] -&gt; map(|x: &amp;str| x.to_lowercase()) -&gt; [1]print;
</code></pre>
<p>(Note that the Rust code inside map needed a little help with type inference after the <code>tee</code>.)</p>
<p>Here is a visualization of the flow that was generated:</p>
<pre class="mermaid">flowchart TB
    subgraph Compiled Component 2
        3v1[&quot;3v1 &lt;tt&gt;op_3v1: merge()&lt;/tt&gt;&quot;]
        4v1[&quot;4v1 &lt;tt&gt;op_4v1: for_each(| x | println! (&amp;quot;{}&amp;quot;, x))&lt;/tt&gt;&quot;]
    end
    subgraph Compiled Component 1
        1v1[&quot;1v1 &lt;tt&gt;op_1v1: source_iter(vec! [&amp;quot;Hello&amp;quot;, &amp;quot;world&amp;quot;])&lt;/tt&gt;&quot;]
        2v1[&quot;2v1 &lt;tt&gt;op_2v1: tee()&lt;/tt&gt;&quot;]
        5v1[&quot;5v1 &lt;tt&gt;op_5v1: map(| x : &amp;amp; str | x.to_uppercase())&lt;/tt&gt;&quot;]
        6v1[&quot;6v1 &lt;tt&gt;op_6v1: map(| x : &amp;amp; str | x.to_lowercase())&lt;/tt&gt;&quot;]
    end

    7v1{&quot;handoff&quot;}
    8v1{&quot;handoff&quot;}

    1v1--&gt;2v1
    2v1--&gt;5v1
    2v1--&gt;6v1
    3v1--&gt;4v1
    5v1--&gt;7v1
    6v1--&gt;8v1
    7v1--&gt;3v1
    8v1--&gt;3v1
</pre>
<p>Hydroflow compiled this flow into two subgraphs called <em>compiled components</em>, connected by <em>handoffs</em>. You can ignore 
these details unless you are interested in low-level performance tuning; they are explained in the discussion
of <a href="./in-out_trees.html">in-out trees</a>. </p>
<h3 id="a-note-on-assigning-flows-with-multiple-ports"><a class="header" href="#a-note-on-assigning-flows-with-multiple-ports">A note on assigning flows with multiple ports</a></h3>
<blockquote>
<p><em>WARNING</em>: <em>Need to document the port numbers for variables assigned to tree- or dag-shaped flows</em></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-sources-and-sinks-in-rust"><a class="header" href="#data-sources-and-sinks-in-rust">Data Sources and Sinks in Rust</a></h1>
<p>Any useful flow requires us to define sources of data, either generated computationally or received from 
and outside environment via I/O.</p>
<h2 id="source_iter"><a class="header" href="#source_iter"><code>source_iter</code></a></h2>
<p>A flow can receive data from a Rust collection object via the <code>source_iter</code> operator, which takes the 
iterable collection as an argument and passes the items down the flow. 
For example, here we iterate through a vector of <code>usize</code> items and push them down the flow:</p>
<pre><code class="language-rust ignore">    source_iter(vec![0, 1]) -&gt; ...
</code></pre>
<p>The Hello, World example above uses this construct.</p>
<h2 id="source_stream"><a class="header" href="#source_stream"><code>source_stream</code></a></h2>
<p>More commonly, a flow should handle external data coming in asynchronously from a <a href="https://tokio.rs/tokio/tutorial"><em>Tokio</em> runtime</a>.
One way to do this is with <em>channels</em> that allow Rust code to send data into the Hydroflow inputs.
The code below creates a channel for data of (Rust) type <code>(usize, usize)</code>:</p>
<pre><code class="language-rust ignore">    let (input_send, input_recv) = hydroflow::util::unbounded_channel::&lt;(usize, usize)&gt;();
</code></pre>
<p>Under the hood this uses <a href="https://docs.rs/tokio/latest/tokio/sync/mpsc/fn.unbounded_channel.html">Tokio unbounded channels</a>.
Now in Rust we can now push data into the channel. E.g. for testing we can do
it explicitly as follows:</p>
<pre><code class="language-rust ignore">    input_send.send((0, 1)).unwrap()
</code></pre>
<p>And in our Hydroflow syntax we can receive the data from the channel using the <code>source_stream</code> syntax and
pass it along a flow:</p>
<pre><code class="language-rust ignore">    source_stream(input_recv) -&gt; ...
</code></pre>
<p>To put this together, let's revisit our Hello, World example from above with data sent 
in from outside the flow:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use hydroflow::hydroflow_syntax;
</span>let (input_send, input_recv) = hydroflow::util::unbounded_channel::&lt;&amp;str&gt;();
let mut flow = hydroflow_syntax! {
    source_stream(input_recv) -&gt; map(|x| x.to_uppercase())
        -&gt; for_each(|x| println!(&quot;{}&quot;, x));
};
input_send.send(&quot;Hello&quot;).unwrap();
input_send.send(&quot;World&quot;).unwrap();
flow.run_available();
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><!-- GENERATED "hydroflow_macro/build.rs" -->
<h1 id="hydroflows-built-in-operators"><a class="header" href="#hydroflows-built-in-operators">Hydroflow's Built-in Operators</a></h1>
<p>In our previous examples we made use of some of Hydroflow's built-in operators.
Here we document each operators in more detail. Most of these operators
are based on the Rust equivalents for iterators; see the <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">Rust documentation</a>.</p>
<h2 id="null"><a class="header" href="#null"><code>null</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th></tr></thead><tbody>
<tr><td><span title="at least 0 and at most 1">at least 0 and at most 1</span></td><td><code>null()</code></td><td><span title="at least 0 and at most 1">at least 0 and at most 1</span></td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/null.rs" -->
<blockquote>
<p>unbounded number of input streams of any type, unbounded number of output streams of any type.</p>
</blockquote>
<p>As a source, generates nothing. As a sink, absorbs anything with no effect.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::tl;
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>// should print `1, 2, 3, 4, 5, 6, a, b, c` across 9 lines
null() -&gt; for_each(|_: ()| panic!());
source_iter([1,2,3]) -&gt; map(|i| println!(&quot;{}&quot;, i)) -&gt; null();
null_src = null();
null_sink = null();
null_src[0] -&gt; for_each(|_: ()| panic!());
// note: use `for_each()` (or `inspect()`) instead of this:
source_iter([4,5,6]) -&gt; map(|i| println!(&quot;{}&quot;, i)) -&gt; [0]null_sink;
<span class="boring">};
</span><span class="boring">__hf.run_available();
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="merge"><a class="header" href="#merge"><code>merge</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th></tr></thead><tbody>
<tr><td><span title="at least 0">at least 2</span></td><td><code>-&gt; merge() -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/merge.rs" -->
<blockquote>
<p><em>n</em> input streams of the same type, 1 output stream of the same type</p>
</blockquote>
<p>Merges an arbitrary number of input streams into a single stream. Each input sequence is a subsequence of the output, but no guarantee is given on how the inputs are interleaved.</p>
<p>Since <code>merge</code> has multiple input streams, it needs to be assigned to
a variable to reference its multiple input ports across statements.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::tl;
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>my_merge = merge();
source_iter(vec![&quot;hello&quot;, &quot;world&quot;]) -&gt; my_merge;
source_iter(vec![&quot;stay&quot;, &quot;gold&quot;]) -&gt; my_merge;
source_iter(vec![&quot;don\'t&quot;, &quot;give&quot;, &quot;up&quot;]) -&gt; my_merge;
my_merge -&gt; map(|x| x.to_uppercase())
    -&gt; for_each(|x| println!(&quot;{}&quot;, x));
<span class="boring">};
</span><span class="boring">__hf.run_available();
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="join"><a class="header" href="#join"><code>join</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th></tr></thead><tbody>
<tr><td><span title="exactly 2">exactly 2</span></td><td><code>-&gt; join() -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td></tr>
</tbody></table>
</div>
<blockquote>
<p>Input port names: <code>0</code>, <code>1</code></p>
</blockquote>
<!-- GENERATED "hydroflow_lang/src/graph/ops/join.rs" -->
<blockquote>
<p>2 input streams of type &lt;(K, V1)&gt; and &lt;(K, V2)&gt;, 1 output stream of type &lt;(K, (V1, V2))&gt;</p>
</blockquote>
<p>Forms the equijoin of the tuples in the input streams by their first (key) attribute. Note that the result nests the 2nd input field (values) into a tuple in the 2nd output field.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::tl;
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>// should print `(hello, (world, cleveland))`
my_join = join();
source_iter(vec![(&quot;hello&quot;, &quot;world&quot;), (&quot;stay&quot;, &quot;gold&quot;)]) -&gt; [0]my_join;
source_iter(vec![(&quot;hello&quot;, &quot;cleveland&quot;)]) -&gt; [1]my_join;
my_join -&gt; for_each(|(k, (v1, v2))| println!(&quot;({}, ({}, {}))&quot;, k, v1, v2));
<span class="boring">};
</span><span class="boring">__hf.run_available();
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="cross_join"><a class="header" href="#cross_join"><code>cross_join</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th></tr></thead><tbody>
<tr><td><span title="exactly 2">exactly 2</span></td><td><code>-&gt; cross_join() -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td></tr>
</tbody></table>
</div>
<blockquote>
<p>Input port names: <code>0</code>, <code>1</code></p>
</blockquote>
<!-- GENERATED "hydroflow_lang/src/graph/ops/cross_join.rs" -->
<blockquote>
<p>2 input streams of type S and T, 1 output stream of type (S, T)</p>
</blockquote>
<p>Forms the cross-join (Cartesian Product) of the items in the input streams, returning all tupled pairs.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::tl;
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>// should print all 4 pairs of emotion and animal
my_join = cross_join();
source_iter(vec![&quot;happy&quot;, &quot;sad&quot;]) -&gt; [0]my_join;
source_iter(vec![&quot;dog&quot;, &quot;cat&quot;]) -&gt; [1]my_join;
my_join -&gt; for_each(|(v1, v2)| println!(&quot;({}, {})&quot;, v1, v2));
<span class="boring">};
</span><span class="boring">__hf.run_available();
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="tee"><a class="header" href="#tee"><code>tee</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; tee() -&gt;</code></td><td><span title="at least 0">at least 2</span></td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/tee.rs" -->
<blockquote>
<p>1 input stream, <em>n</em> output streams</p>
</blockquote>
<p>Takes the input stream and delivers a copy of each item to each output.</p>
<blockquote>
<p>Note: Downstream operators may need explicit type annotations.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::tl;
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>my_tee = source_iter(vec![&quot;Hello&quot;, &quot;World&quot;]) -&gt; tee();
my_tee -&gt; map(|x: &amp;str| x.to_uppercase())
    -&gt; for_each(|x| println!(&quot;{}&quot;, x));
my_tee -&gt; map(|x: &amp;str| x.to_lowercase())
    -&gt; for_each(|x| println!(&quot;{}&quot;, x));
my_tee -&gt; for_each(|x: &amp;str| println!(&quot;{}&quot;, x));
<span class="boring">};
</span><span class="boring">__hf.run_available();
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="unzip"><a class="header" href="#unzip"><code>unzip</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; unzip() -&gt;</code></td><td><span title="exactly 2">exactly 2</span></td></tr>
</tbody></table>
</div>
<blockquote>
<p>Output port names: <code>0</code>, <code>1</code></p>
</blockquote>
<!-- GENERATED "hydroflow_lang/src/graph/ops/unzip.rs" -->
<blockquote>
<p>1 input stream of pair tuples <code>(A, B)</code>, 2 output streams</p>
</blockquote>
<p>Takes the input stream of pairs and unzips each one, delivers each item to
its corresponding side.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::tl;
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>my_unzip = source_iter(vec![(&quot;Hello&quot;, &quot;Foo&quot;), (&quot;World&quot;, &quot;Bar&quot;)]) -&gt; unzip();
my_unzip[0] -&gt; for_each(|x| println!(&quot;0: {}&quot;, x)); // Hello World
my_unzip[1] -&gt; for_each(|x| println!(&quot;1: {}&quot;, x)); // Foo Bar
<span class="boring">};
</span><span class="boring">__hf.run_available();
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="identity"><a class="header" href="#identity"><code>identity</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; identity() -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/identity.rs" -->
<blockquote>
<p>1 input stream of type T, 1 output stream of type T</p>
</blockquote>
<p>For each item passed in, pass it out without any change.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::tl;
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>// should print &quot;hello&quot; and &quot;world&quot; on separate lines (in either order)
source_iter(vec![&quot;hello&quot;, &quot;world&quot;]) -&gt; identity()
    -&gt; for_each(|x| println!(&quot;{}&quot;, x));
<span class="boring">};
</span><span class="boring">__hf.run_available();
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="map"><a class="header" href="#map"><code>map</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; map(A) -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/map.rs" -->
<blockquote>
<p>1 input stream, 1 output stream</p>
</blockquote>
<blockquote>
<p>Arguments: A Rust closure
For each item passed in, apply the closure to generate an item to emit.</p>
</blockquote>
<p>If you do not want to modify the item stream and instead only want to view
each item use the <a href="surface_ops.gen.html#inspect"><code>inspect</code></a> operator instead.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::tl;
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>source_iter(vec![&quot;hello&quot;, &quot;world&quot;]) -&gt; map(|x| x.to_uppercase())
    -&gt; for_each(|x| println!(&quot;{}&quot;, x));
<span class="boring">};
</span><span class="boring">__hf.run_available();
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="inspect"><a class="header" href="#inspect"><code>inspect</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; inspect(A) -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/inspect.rs" -->
<blockquote>
<p>Arguments: A single closure <code>FnMut(&amp;Item)</code>.</p>
</blockquote>
<p>An operator which allows you to &quot;inspect&quot; each element of a stream without
modifying it. The closure is called on a reference to each item. This is
mainly useful for debugging as in the example below, and it is generally an
anti-pattern to provide a closure with side effects.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::tl;
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>source_iter([1, 2, 3, 4]) -&gt; inspect(|&amp;x| println!(&quot;{}&quot;, x)) -&gt; null();
<span class="boring">};
</span><span class="boring">__hf.run_available();
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="flat_map"><a class="header" href="#flat_map"><code>flat_map</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; flat_map(A) -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/flat_map.rs" -->
<blockquote>
<p>1 input stream, 1 output stream</p>
</blockquote>
<blockquote>
<p>Arguments: A Rust closure that handles an iterator</p>
</blockquote>
<p>For each item <code>i</code> passed in, treat <code>i</code> as an iterator and map the closure to that
iterator to produce items one by one. The type of the input items must be iterable.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::tl;
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>// should print out each character of each word on a separate line
source_iter(vec![&quot;hello&quot;, &quot;world&quot;]) -&gt; flat_map(|x| x.chars())
    -&gt; for_each(|x| println!(&quot;{}&quot;, x));
<span class="boring">};
</span><span class="boring">__hf.run_available();
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="flatten"><a class="header" href="#flatten"><code>flatten</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; flatten() -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/flatten.rs" -->
<blockquote>
<p>1 input stream, 1 output stream</p>
</blockquote>
<p>For each item <code>i</code> passed in, treat <code>i</code> as an iterator and produce its items one by one.
The type of the input items must be iterable.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::tl;
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>// should print the numbers 1-6 without any nesting
source_iter(vec![[1, 2], [3, 4], [5, 6]]) -&gt; flatten()
-&gt; for_each(|x| println!(&quot;{}&quot;, x));
<span class="boring">};
</span><span class="boring">__hf.run_available();
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="filter_map"><a class="header" href="#filter_map"><code>filter_map</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; filter_map(A) -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/filter_map.rs" -->
<blockquote>
<p>1 input stream, 1 output stream</p>
</blockquote>
<p>An operator that both filters and maps. It yields only the items for which the supplied closure returns <code>Some(value)</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::tl;
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>source_iter(vec![&quot;1&quot;, &quot;hello&quot;, &quot;world&quot;, &quot;2&quot;]) -&gt; filter_map(|s| s.parse().ok())
    -&gt; for_each(|x: usize| println!(&quot;{}&quot;, x));
<span class="boring">};
</span><span class="boring">__hf.run_available();
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="filter"><a class="header" href="#filter"><code>filter</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; filter(A) -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/filter.rs" -->
<p>Filter outputs a subsequence of the items it receives at its input, according to a
Rust boolean closure passed in as an argument.</p>
<blockquote>
<p>TODO: Why does filter's closure expect a reference and other ops like map do not?</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::tl;
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>source_iter(vec![&quot;hello&quot;, &quot;world&quot;]) -&gt; filter(|x| x.starts_with('w'))
    -&gt; for_each(|x| println!(&quot;{}&quot;, x));
<span class="boring">};
</span><span class="boring">__hf.run_available();
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="fold"><a class="header" href="#fold"><code>fold</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; fold(A, B) -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/fold.rs" -->
<blockquote>
<p>1 input stream, 1 output stream</p>
</blockquote>
<blockquote>
<p>Arguments: an initial value, and a closure which itself takes two arguments:
an 'accumulator', and an element. The closure returns the value that the accumulator should have for the next iteration.</p>
</blockquote>
<p>Akin to Rust's built-in fold operator. Folds every element into an accumulator by applying a closure,
returning the final result.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::tl;
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>// should print `Reassembled vector [1,2,3,4,5]`
source_iter([1,2,3,4,5])
    -&gt; fold(Vec::new(), |mut accum, elem| {
        accum.push(elem);
        accum
    })
    -&gt; for_each(|e| println!(&quot;Ressembled vector {:?}&quot;, e));
<span class="boring">};
</span><span class="boring">__hf.run_available();
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="reduce"><a class="header" href="#reduce"><code>reduce</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; reduce(A) -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/reduce.rs" -->
<blockquote>
<p>1 input stream, 1 output stream</p>
</blockquote>
<blockquote>
<p>Arguments: a closure which itself takes two arguments:
an ‘accumulator’, and an element. The closure returns the value that the accumulator should have for the next iteration.</p>
</blockquote>
<p>Akin to Rust's built-in reduce operator. Folds every element into an accumulator by applying a closure,
returning the final result.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::tl;
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>// should print 120 (i.e., 1*2*3*4*5)
source_iter([1,2,3,4,5])
    -&gt; reduce(|mut accum, elem| {
        accum *= elem;
        accum
    })
    -&gt; for_each(|e| println!(&quot;{}&quot;, e));
<span class="boring">};
</span><span class="boring">__hf.run_available();
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="groupby"><a class="header" href="#groupby"><code>groupby</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; groupby(A, B) -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/groupby.rs" -->
<blockquote>
<p>1 input stream of type (K,V1), 1 output stream of type (K,V2).
The output will have one tuple for each distinct K, with an accumulated value of type V2.</p>
</blockquote>
<blockquote>
<p>Arguments: two Rust closures. The first generates an initial value per group. The second itself takes two arguments:
an 'accumulator', and an element. The second closure returns the value that the accumulator should have for the next iteration.</p>
</blockquote>
<p>A special case of <code>fold</code>, in the spirit of SQL's GROUP BY and aggregation constructs.
The input is partitioned into groups by the first field, and for each group the values in the second field
are accumulated via the closures in the arguments.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::tl;
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>source_iter([(&quot;toy&quot;, 1), (&quot;toy&quot;, 2), (&quot;shoe&quot;, 11), (&quot;shoe&quot;, 35), (&quot;haberdashery&quot;, 7)])
    -&gt; groupby(|| 0, |old: &amp;mut u32, val: u32| *old += val)
    -&gt; for_each(|(k, v)| println!(&quot;Total for group {} is {}&quot;, k, v));
<span class="boring">};
</span><span class="boring">__hf.run_available();
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="unique"><a class="header" href="#unique"><code>unique</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; unique() -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/unique.rs" -->
<p>Takes one stream as input and filters out any duplicate occurrences. The output
contains all unique values from the input.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::tl;
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>// should print 1, 2, 3 (in any order)
source_iter(vec![1, 1, 2, 3, 2, 1, 3])
    -&gt; unique()
    -&gt; for_each(|x| println!(&quot;{}&quot;, x));
<span class="boring">};
</span><span class="boring">__hf.run_available();
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="sort"><a class="header" href="#sort"><code>sort</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; sort() -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/sort.rs" -->
<p>Takes a stream as input and produces a sorted version of the stream as output.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::tl;
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>// should print 1, 2, 3 (in order)
source_iter(vec![2, 3, 1])
    -&gt; sort()
    -&gt; for_each(|x| println!(&quot;{}&quot;, x));
<span class="boring">};
</span><span class="boring">__hf.run_available();
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="source_iter-1"><a class="header" href="#source_iter-1"><code>source_iter</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th></tr></thead><tbody>
<tr><td><span title="exactly 0">exactly 0</span></td><td><code>source_iter(A) -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/source_iter.rs" -->
<blockquote>
<p>0 input streams, 1 output stream</p>
</blockquote>
<blockquote>
<p>Arguments: An iterable Rust object.
Takes the iterable object and delivers its elements downstream
one by one.</p>
</blockquote>
<p>Note that all elements are emitted during the first epoch.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::tl;
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>    source_iter(vec![&quot;Hello&quot;, &quot;World&quot;])
        -&gt; for_each(|x| println!(&quot;{}&quot;, x));
<span class="boring">};
</span><span class="boring">__hf.run_available();
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="source_stdin"><a class="header" href="#source_stdin"><code>source_stdin</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th></tr></thead><tbody>
<tr><td><span title="exactly 0">exactly 0</span></td><td><code>source_stdin() -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/source_stdin.rs" -->
<blockquote>
<p>0 input streams, 1 output stream</p>
</blockquote>
<blockquote>
<p>Arguments: port number</p>
</blockquote>
<p><code>source_stdin</code> receives a Stream of lines from stdin
and emits each of the elements it receives downstream.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut flow = hydroflow::hydroflow_syntax! {
    source_stdin() -&gt; map(|x| x.unwrap().to_uppercase())
        -&gt; for_each(|x| println!(&quot;{}&quot;, x));
};
flow.run_async();
<span class="boring">}
</span></code></pre></pre>
<h2 id="source_stream-1"><a class="header" href="#source_stream-1"><code>source_stream</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th></tr></thead><tbody>
<tr><td><span title="exactly 0">exactly 0</span></td><td><code>source_stream(A) -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/source_stream.rs" -->
<blockquote>
<p>0 input streams, 1 output stream</p>
</blockquote>
<blockquote>
<p>Arguments: The receive end of a tokio channel</p>
</blockquote>
<p>Given a <a href="https://docs.rs/futures/latest/futures/stream/trait.Stream.html"><code>Stream</code></a>
created in Rust code, <code>source_stream</code>
is passed the receive endpoint of the channel and emits each of the
elements it receives downstream.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (input_send, input_recv) = hydroflow::util::unbounded_channel::&lt;&amp;str&gt;();
let mut flow = hydroflow::hydroflow_syntax! {
    source_stream(input_recv) -&gt; map(|x| x.to_uppercase())
        -&gt; for_each(|x| println!(&quot;{}&quot;, x));
};
input_send.send(&quot;Hello&quot;).unwrap();
input_send.send(&quot;World&quot;).unwrap();
flow.run_available();
<span class="boring">}
</span></code></pre></pre>
<h2 id="source_stream_serde"><a class="header" href="#source_stream_serde"><code>source_stream_serde</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th></tr></thead><tbody>
<tr><td><span title="exactly 0">exactly 0</span></td><td><code>source_stream_serde(A) -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/source_stream_serde.rs" -->
<blockquote>
<p>0 input streams, 1 output stream</p>
</blockquote>
<blockquote>
<p>Arguments: <a href="https://docs.rs/futures/latest/futures/stream/trait.Stream.html"><code>Stream</code></a></p>
</blockquote>
<p>Given a <a href="https://docs.rs/futures/latest/futures/stream/trait.Stream.html"><code>Stream</code></a>
of (serialized payload, addr) pairs, deserializes the payload and emits each of the
elements it receives downstream.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn serde_in() {
    let (outbound, inbound) = hydroflow::util::bind_udp_socket(&quot;localhost:9000&quot;.into()).await;
    let mut flow = hydroflow::hydroflow_syntax! {
        source_stream_serde(inbound) -&gt; map(|(x, a): (String, std::net::SocketAddr)| x.to_uppercase())
            -&gt; for_each(|x| println!(&quot;{}&quot;, x));
    };
    flow.run_available();
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="repeat_iter"><a class="header" href="#repeat_iter"><code>repeat_iter</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th></tr></thead><tbody>
<tr><td><span title="exactly 0">exactly 0</span></td><td><code>repeat_iter(A) -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/repeat_iter.rs" -->
<h2 id="difference"><a class="header" href="#difference"><code>difference</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th></tr></thead><tbody>
<tr><td><span title="exactly 2">exactly 2</span></td><td><code>-&gt; difference() -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td></tr>
</tbody></table>
</div>
<blockquote>
<p>Input port names: <code>pos</code>, <code>neg</code></p>
</blockquote>
<!-- GENERATED "hydroflow_lang/src/graph/ops/difference.rs" -->
<blockquote>
<p>2 input streams of the same type T, 1 output stream of type T</p>
</blockquote>
<p>For a given epoch, forms the set difference of the items in the input
streams, returning items in the <code>pos</code> input that are not found in the
<code>neg</code> input.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::tl;
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>// should print &quot;elephant&quot;
diff = difference();
source_iter(vec![&quot;dog&quot;, &quot;cat&quot;, &quot;elephant&quot;]) -&gt; [pos]diff;
source_iter(vec![&quot;dog&quot;, &quot;cat&quot;, &quot;gorilla&quot;]) -&gt; [neg]diff;
diff -&gt; for_each(|v| println!(&quot;{}&quot;, v));
<span class="boring">};
</span><span class="boring">__hf.run_available();
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="next_stratum"><a class="header" href="#next_stratum"><code>next_stratum</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; next_stratum() -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/next_stratum.rs" -->
<p>Delays all elements which pass through to the next stratum (in the same
epoch).</p>
<h2 id="next_epoch"><a class="header" href="#next_epoch"><code>next_epoch</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; next_epoch() -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/next_epoch.rs" -->
<p>Delays all elements which pass through to the next epoch. In short,
execution of a hydroflow graph runs as a sequence of distinct &quot;epochs&quot;.
Non-monotonic operators compute their output in terms of each epoch so
execution doesn't have to block, and it is up to the user to coordinate
data between epoch executions to achieve the desired result.</p>
<p>An epoch may be divided into multiple <em>strata</em>, see the <a href="surface_ops.gen.html#next_stratum"><code>next_stratum()</code></a>
operator.</p>
<p>In the example below <code>next_epoch()</code> is used alongside <code>difference()</code> to
ignore any items in the current epoch that already appeared in the previous
epoch.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Outputs 1 2 3 4 5 6 (on separate lines).
let (input_send, input_recv) = hydroflow::util::unbounded_channel::&lt;usize&gt;();
let mut flow = hydroflow::hydroflow_syntax! {
    inp = source_stream(input_recv) -&gt; tee();
    diff = difference() -&gt; for_each(|x| println!(&quot;{}&quot;, x));
    inp -&gt; [pos]diff;
    inp -&gt; next_epoch() -&gt; [neg]diff;
};

for x in [1, 2, 3, 4] {
    input_send.send(x).unwrap();
}
flow.run_epoch();

for x in [3, 4, 5, 6] {
    input_send.send(x).unwrap();
}
flow.run_epoch();
<span class="boring">}
</span></code></pre></pre>
<h2 id="for_each"><a class="header" href="#for_each"><code>for_each</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; for_each(A)</code></td><td><span title="exactly 0">exactly 0</span></td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/for_each.rs" -->
<blockquote>
<p>1 input stream, 0 output streams</p>
</blockquote>
<blockquote>
<p>Arguments: a Rust closure</p>
</blockquote>
<p>Iterates through a stream passing each element to the closure in the
argument.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::tl;
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>    source_iter(vec![&quot;Hello&quot;, &quot;World&quot;])
        -&gt; for_each(|x| println!(&quot;{}&quot;, x));
<span class="boring">};
</span><span class="boring">__hf.run_available();
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="demux"><a class="header" href="#demux"><code>demux</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; demux(A) -&gt;</code></td><td><span title="at least 2">at least 2</span></td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/demux.rs" -->
<blockquote>
<p>Arguments: A Rust closure, the first argument is a received item and the
second argument is a <a href="https://hydro-project.github.io/hydroflow/doc/hydroflow/macro.tl.html"><code>tl!</code> tuple list</a>
where each item name is an output port.</p>
</blockquote>
<p>Takes the input stream and allows the user to determine what elemnt(s) to
deliver to any number of output streams.</p>
<blockquote>
<p>Note: Downstream operators may need explicit type annotations.</p>
</blockquote>
<blockquote>
<p>Note: Import the <a href="https://hydro-project.github.io/hydroflow/doc/pusherator/trait.Pusherator.html"><code>Pusherator</code></a>
trait to use the <a href="https://hydro-project.github.io/hydroflow/doc/pusherator/trait.Pusherator.html#tymethod.give"><code>.give(...)</code> method</a>.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::tl;
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>my_demux = source_iter(1..=100) -&gt; demux(|v, tl!(fzbz, fizz, buzz, vals)|
    match (v % 3, v % 5) {
        (0, 0) =&gt; fzbz.give(v),
        (0, _) =&gt; fizz.give(v),
        (_, 0) =&gt; buzz.give(v),
        (_, _) =&gt; vals.give(v),
    }
);
my_demux[fzbz] -&gt; for_each(|v| println!(&quot;{}: fizzbuzz&quot;, v));
my_demux[fizz] -&gt; for_each(|v| println!(&quot;{}: fizz&quot;, v));
my_demux[buzz] -&gt; for_each(|v| println!(&quot;{}: buzz&quot;, v));
my_demux[vals] -&gt; for_each(|v| println!(&quot;{}&quot;, v));
<span class="boring">};
</span><span class="boring">__hf.run_available();
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="dest_asyncwrite"><a class="header" href="#dest_asyncwrite"><code>dest_asyncwrite</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; dest_asyncwrite(A)</code></td><td><span title="exactly 0">exactly 0</span></td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/dest_asyncwrite.rs" -->
<blockquote>
<p>Arguments: An <a href="https://docs.rs/tokio/latest/tokio/io/trait.AsyncWrite.html"><code>AsyncWrite</code></a>.</p>
</blockquote>
<p>Consumes a stream of bytes (specifically <code>AsRef[u8]</code> items) by writing them
to an <a href="https://docs.rs/tokio/latest/tokio/io/trait.AsyncWrite.html"><code>AsyncWrite</code></a>
output.</p>
<p>This handles a stream of bytes, whereas <a href="surface_ops.gen.html#dest_sink"><code>dest_sink</code></a> handles individual items of an arbitrary type.</p>
<p>Note this operator must be used within a Tokio runtime.</p>
<h2 id="dest_sink"><a class="header" href="#dest_sink"><code>dest_sink</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; dest_sink(A)</code></td><td><span title="exactly 0">exactly 0</span></td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/dest_sink.rs" -->
<blockquote>
<p>Arguments: An <a href="https://docs.rs/futures/latest/futures/sink/trait.Sink.html">async <code>Sink</code></a>.</p>
</blockquote>
<p>Consumes items by sending them to an <a href="https://docs.rs/futures/latest/futures/sink/trait.Sink.html">async <code>Sink</code></a>.</p>
<p>This handles a stream of individual items, of an arbitrary type, whereas <a href="surface_ops.gen.html#dest_asyncwrite"><code>dest_asyncwrite</code></a>
handles streams of bytes.</p>
<p>Note this operator must be used within a Tokio runtime.</p>
<h2 id="dest_sink_serde"><a class="header" href="#dest_sink_serde"><code>dest_sink_serde</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; dest_sink_serde(A)</code></td><td><span title="exactly 0">exactly 0</span></td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/dest_sink_serde.rs" -->
<blockquote>
<p>Arguments: A <a href="https://docs.rs/futures/latest/futures/sink/trait.Sink.html">serializing async <code>Sink</code></a>.</p>
</blockquote>
<p>Consumes (payload, addr) pairs by serializing the payload and sending the resulting pair to an <a href="https://docs.rs/futures/latest/futures/sink/trait.Sink.html">async <code>Sink</code></a>.</p>
<p>Note this operator must be used within a Tokio runtime.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn serde_out() {
    let (outbound, inbound) = hydroflow::util::bind_udp_socket(&quot;localhost:9000&quot;.into()).await;
    let remote = hydroflow::util::ipv4_resolve(&quot;localhost:9001&quot;.into());
    let mut flow = hydroflow::hydroflow_syntax! {
        source_iter(vec![(&quot;hello&quot;.to_string(), 1), (&quot;world&quot;.to_string(), 2)])
            -&gt; map (|m| (m, remote)) -&gt; dest_sink_serde(outbound);
    };
    flow.run_available();
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture"><a class="header" href="#architecture">Architecture</a></h1>
<p>Hydroflow graphs are divided into two layers: the outer <em>scheduled layer</em> and
inner <em>compiled layer</em>.</p>
<p>The <a href="https://hydro-project.github.io/hydroflow/design_docs/2021-10_architecture_design_doc.html">Hydroflow Architecture Design Doc</a>
contains a more detailed explanation of this section. Note that some aspects of
the design doc are not implemented (e.g. early yielding) or may become out of
date as time passes.</p>
<h2 id="scheduled-layer"><a class="header" href="#scheduled-layer">Scheduled Layer</a></h2>
<p>The scheduled layer is dynamic: it stores a list of operators (or &quot;subgraphs&quot;)
as well as buffers (&quot;handoffs&quot;) between them. The scheduled layer chooses how
to schedule the operators (naturally), and when each operator runs it pulls
from its input handoffs and pushes to its output handoffs. This setup is
extremely flexible: operators can have any number of input or output handoffs
so we can easily represent any graph topology. However this flexibility comes
at a performance cost due to the overhead of scheduling, buffering, and lack
of inter-operator compiler optimization.</p>
<p>The <em>compiled layer</em> helps avoids the costs of the scheduled layer. We can
combine several operators into a <em>subgraph</em> which are compiled and optimized as
a single scheduled subgraph. The scheduled layer then runs the entire subgraph
as if it was one operator with many inputs and outputs. Note the layering here:
the compiled layer does not replace the scheduled layer but instead exists
within it.</p>
<h2 id="compiled-layer"><a class="header" href="#compiled-layer">Compiled Layer</a></h2>
<p>Rust already has a built-in API similar to dataflow: <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code>Iterator</code>s</a>.
When they work well, they work really well and tend to be as fast as for loops.
However, they are limited in the flow graphs they can represent. Each operator
in a <code>Iterator</code> takes ownership of, and <em>pulls</em> from, the previous operator.
Taking two iterators as <em>inputs</em> and merging them together (e.g. with
<a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.chain"><code>.chain(...)</code></a>
or <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.zip"><code>.zip(...)</code></a>)
is natural and performant as we can <em>pull</em> from both. However if we want an
iterator to split into multiple <em>outputs</em> then things become tricky. <a href="https://docs.rs/itertools/latest/itertools/trait.Itertools.html#method.tee"><code>Itertools::tee()</code></a>
does just this by cloning each incoming item into two output buffers, but this
requires allocation and could cause unbounded buffer growth if the outputs are
not read from evenly.</p>
<p>However, if instead iterators were <em>push</em>-based, where each operator owns one
or more <em>output</em> operators, then teeing is very easy, just clone each element
and push to (i.e. run) both outputs. So that's what we did, created push-based
iterators to allow fast teeing or splitting in the compiled layer.</p>
<p>Pull-based iterators can be connected to push-based iterators at a single &quot;pivot&quot;
point. Together, this pull-to-push setup dictates the shape compiled subgraphs
can take. Informally, this is like the roots and leaves of a tree. Water flows
from the roots (the pull inputs), eventually all join together in the trunk
(the pull-to-push pivot), the split up into multiple outputs in the leaves.
We refer to this structure as an <em>in-out tree</em>.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center"></th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="img/oaklandish_logo.jpg" alt="The Oaklandish Logo depicting the stylized roots, trunk, and branches of a tree." /></td></tr>
<tr><td style="text-align: center">The Oaklandish Logo.</td></tr>
</tbody></table>
</div>
<p>See <a href="./in-out_trees.html">Subgraph In-Out Trees</a> for more, including how to
convert a graph into in-out trees.</p>
<h2 id="surface-syntax-and-apis"><a class="header" href="#surface-syntax-and-apis">Surface Syntax and APIs</a></h2>
<p>You can interact with Hydroflow at a high level with a <em>Surface Syntax</em> that hides
the distinction between these two layers. It offers a natural <code>Iterator</code>-like chaining syntax for building 
graphs that get parsed and compiled into a scheduled graph of one or more compiled subgraphs. Please see the <a href="./surface_syntax.html">Surface Syntax</a> docs for more information.</p>
<blockquote>
<p><strong>Deprecated</strong>:  There is a <em>Surface API</em> that provides an <code>Iterator</code>-like chaining syntax in Rust. The Surface API code lives in <a href="https://hydro-project.github.io/hydroflow/doc/hydroflow/builder/index.html"><code>hydroflow::builder</code></a>. Some of the examples still use this API.</p>
</blockquote>
<p>Alternatively, the <em>Core API</em> allows you to interact with handoffs directly at a low
level. It doesn't provide any notion of chainable operators. You can use Rust <code>Iterator</code>s
or any other arbitrary Rust code to implement the operators.</p>
<p>The Core API lives in <a href="https://hydro-project.github.io/hydroflow/doc/hydroflow/scheduled/index.html"><code>hydroflow::scheduled</code></a>,
mainly in methods on the <a href="https://hydro-project.github.io/hydroflow/doc/hydroflow/scheduled/graph/struct.Hydroflow.html"><code>Hydroflow</code> struct</a>.  Compiled push-based iterators live in <a href="https://hydro-project.github.io/hydroflow/doc/hydroflow/compiled/index.html"><code>hydroflow::compiled</code></a>. We intend users to use the Surface Syntax as it is much more friendly, but as
Hydroflow is in active development some operators might not be available in
the Surface Syntax, in which case the Core API can be used instead. If you find
yourself in this sitation be sure to <a href="https://github.com/hydro-project/hydroflow/issues/new">submit an issue</a>!</p>
<h2 id="scheduling"><a class="header" href="#scheduling">Scheduling</a></h2>
<h2 id="handoffs"><a class="header" href="#handoffs">Handoffs</a></h2>
<h2 id="networking"><a class="header" href="#networking">Networking</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="subgraph-in-out-trees"><a class="header" href="#subgraph-in-out-trees">Subgraph In-Out Trees</a></h1>
<p>Formally, we define an in-out-tree is the union of an
<em>in-tree</em> (<a href="https://en.wikipedia.org/wiki/Arborescence_%28graph_theory%29#cite_ref-KorteVygen2012b_17-0"><em>anti-arborescence</em></a>)
with an <em>out-tree</em> (<a href="https://en.wikipedia.org/wiki/Arborescence_%28graph_theory%29"><em>arborescence</em></a>)
where both trees share the same <em>root</em> node.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center"></th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="img/in-out_tree.png" alt="A graph showing multiple nodes on the left all eventually feeding into a central pivot node, then continuing to multiple output nodes." /></td></tr>
<tr><td style="text-align: center">An <em>in-out tree</em> graph. Data flows from the green <em>pull</em> operators on the left, through the yellow pivot, and to the red <em>push</em> operators on the right.</td></tr>
</tbody></table>
</div>
<p>In this graph representation, each node corresponds to an operator, and the
edges direct the flow of data between operators.</p>
<h2 id="converting-graph"><a class="header" href="#converting-graph">Converting Graph</a></h2>
<p>Any graph can be partitioned into in-out trees. Any non-trivial graph will have many possible
partitionings to choose from; a useful heuristic is to partition the graph
into as few subgraphs as possible, in order to minimize scheduling overheads.</p>
<p>Most graphs are pretty simple and can be partitioned with a bit of eye-balling.
To do this systematically, we can use a simple
coloring algorithm.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center"></th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="img/in-out_example.png" alt="A random-looking directed graph with 8 nodes." /></td></tr>
<tr><td style="text-align: center">An example directed graph.</td></tr>
</tbody></table>
</div>
<p>To identify the in-out trees in an arbitrary directed graph, first identify any
nodes which have multiple inputs and outputs and mark these as pull-to-push
<em>pivots</em> (yellow in the example). Mark any nodes with multiple inputs (and a
single output) as <em>pull</em> (green) and any nodes with multiple outputs as <em>push</em>
(red).</p>
<p>In the example:</p>
<div class="table-wrapper"><table><thead><tr><th>Pivots (yellow)</th><th>Pulls (green)</th><th>Pushes (red)</th></tr></thead><tbody>
<tr><td>1, 4</td><td>2</td><td>3, 7</td></tr>
</tbody></table>
</div>
<p>Finally any one-in-one-out nodes should be marked the same as their neighbors
(either green pull or red push). If we have green pull -&gt; red push that becomes
a yellow pivot. And if red push -&gt; green pull that becomes a blue handoff node,
and this is a division between subgraphs. Note that a subgraph can have a
handoff with itself; this forms a loop.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center"></th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="img/in-out_partition.png" alt="The graph above converted and partitioned into two in-out trees." /></td></tr>
<tr><td style="text-align: center">The graph above converted and partitioned into two in-out trees. One is outlined in yellow and the other in red. For the corresponding Hydroflow graph, green nodes are <em>pull</em>, red nodes are <em>push</em>, yellow are <em>pivots</em>, and blue are <em>handoffs</em>.</td></tr>
</tbody></table>
</div>
<p>In the example partitioning above, some nodes have been split into multiple and
labelled with suffixes to make the pivots and handoffs more explicit.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="mermaid.min.js"></script>
        <script type="text/javascript" src="mermaid-init.js"></script>
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
